
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ovito.data &#8212; OVITO 3.4.4 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/rtd.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/ovito.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ovito.io" href="ovito_io.html" />
    <link rel="prev" title="ovito" href="ovito.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ovito_io.html" title="ovito.io"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ovito.html" title="ovito"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OVITO 3.4.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="docutils literal notranslate"><span class="pre">ovito.data</span></code></a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ovito.data">
<span id="ovito-data"></span><h1><code class="docutils literal notranslate"><span class="pre">ovito.data</span></code><a class="headerlink" href="#module-ovito.data" title="Permalink to this headline">¶</a></h1>
<p>This Python module defines various data object types, which are produced and processed within OVITO’s data pipeline system.
It also provides the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> class as a container for such data objects as well as several utility classes for
computing neighbor lists or iterating over the bonds of particles.</p>
<p><strong>Data containers:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a> (base class for all data object types)</p></li>
<li><p><a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> (an entire dataset made of several data objects)</p></li>
<li><p><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> (base container class storing a set of <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> arrays)</p></li>
<li><p><a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> (specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for particles)</p></li>
<li><p><a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> (specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for bonds)</p></li>
<li><p><a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> (specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for 2d and 3d data grids)</p></li>
<li><p><a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> (specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for tabulated data)</p></li>
</ul>
</div></blockquote>
<p><strong>Data objects:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> (array of per-data-element property values)</p></li>
<li><p><a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> (simulation box geometry and boundary conditions)</p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> (triangle mesh describing the boundary surface of a spatial region)</p></li>
<li><p><a class="reference internal" href="#ovito.data.TrajectoryLines" title="ovito.data.TrajectoryLines"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryLines</span></code></a> (set of particle trajectory lines)</p></li>
<li><p><a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a> (set of discrete dislocation lines with Burgers vector information)</p></li>
</ul>
</div></blockquote>
<p><strong>Auxiliary data objects:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> (base class for element type definitions)</p></li>
<li><p><a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> (describes a single particle/atom type)</p></li>
<li><p><a class="reference internal" href="#ovito.data.BondType" title="ovito.data.BondType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondType</span></code></a> (describes a single bond type)</p></li>
<li><p><a class="reference internal" href="#ovito.data.DislocationSegment" title="ovito.data.DislocationSegment"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationSegment</span></code></a> (a dislocation line in a <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a>)</p></li>
</ul>
</div></blockquote>
<p><strong>Utility classes:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.CutoffNeighborFinder" title="ovito.data.CutoffNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code></a> (finds all neighboring particles within a cutoff distance)</p></li>
<li><p><a class="reference internal" href="#ovito.data.NearestNeighborFinder" title="ovito.data.NearestNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code></a> (finds <em>N</em> nearest neighbor particles)</p></li>
<li><p><a class="reference internal" href="#ovito.data.BondsEnumerator" title="ovito.data.BondsEnumerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code></a> (used for efficiently iterating over the bonds of individual particles)</p></li>
</ul>
</div></blockquote>
<dl class="py class">
<dt id="ovito.data.BondType">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">BondType</code><a class="headerlink" href="#ovito.data.BondType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.ElementType</span></code></a></p>
</dd>
</dl>
<p>Represents a bond type. This class inherits all its fields from the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> base class.</p>
<p>You can enumerate the list of defined bond types by accessing the <a class="reference internal" href="#ovito.data.Bonds.bond_types" title="ovito.data.Bonds.bond_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_types</span></code></a> bond property object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bond_type_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">bond_types</span><span class="o">.</span><span class="n">types</span>
<span class="k">for</span> <span class="n">bond_type</span> <span class="ow">in</span> <span class="n">bond_type_list</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">bond_type</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">bond_type</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_type</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="ovito.data.Bonds">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">Bonds</code><a class="headerlink" href="#ovito.data.Bonds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
</dd>
</dl>
<p>Stores the list of bonds and their properties. A <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> object is always part of a parent <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object. 
You can access it as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of bonds:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> class inherits the <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> attribute from its <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class. This attribute returns the number of bonds.</p>
<p><strong>Bond properties</strong></p>
<p>Bonds can be associated with arbitrary <em>bond properties</em>, which are managed in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> container 
as a set of <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data arrays. Each bond property has a unique name by which it can be looked up:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bond property names:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="k">if</span> <span class="s1">&#39;Length&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
    <span class="n">length_prop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="s1">&#39;Length&#39;</span><span class="p">]</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">length_prop</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>New bond properties can be added using the <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropertyContainer.create_property()</span></code></a> method.</p>
<p><strong>Bond topology</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Topology</span></code> bond property, which is always present, 
defines the connectivity between particles in the form of a <em>N</em> x 2 array of indices into the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> array. 
In other words, each bond is defined by a pair of particle indices.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">topology</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bond from particle </span><span class="si">%i</span><span class="s2"> to particle </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the bonds of a system are not stored in any particular order. 
If you need to enumerate all bonds connected to a certain particle, you can use the <a class="reference internal" href="#ovito.data.BondsEnumerator" title="ovito.data.BondsEnumerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code></a> utility class for that.</p>
<p><strong>Bonds visualization</strong></p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> data object has a <a class="reference internal" href="ovito_vis.html#ovito.vis.BondsVis" title="ovito.vis.BondsVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsVis</span></code></a> element attached to it, 
which controls the visual appearance of the bonds in rendered images. It can be accessed through the <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> 
attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shading</span> <span class="o">=</span> <span class="n">BondsVis</span><span class="o">.</span><span class="n">Shading</span><span class="o">.</span><span class="n">Flat</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mf">0.3</span>
</pre></div>
</div>
<p><strong>Computing bond vectors</strong></p>
<p>Since each bond is defined by two indices into the particles array, we can use these indices to determine the corresponding spatial 
bond <em>vectors</em> connecting the particles. They can be computed from the positions of the particles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topology</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">topology</span>
<span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span>
<span class="n">bond_vectors</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">topology</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">topology</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
<p>Here, the first and the second column of the bonds topology array are used to index into the particle positions array. 
The subtraction of the two indexed arrays yields the list of bond vectors. Each vector in this list points 
from the first particle to the second particle of the corresponding bond.</p>
<p>Finally, we may have to correct for the effect of periodic boundary conditions when a bond 
connects two particles on opposite sides of the box. OVITO keeps track of such cases by means of the 
the special <code class="docutils literal notranslate"><span class="pre">Periodic</span> <span class="pre">Image</span></code> bond property. It stores a shift vector for each bond, specifying the directions in which the bond 
crosses periodic boundaries. We make use of this information to correct the bond vectors computed above.
This is done by adding the product of the cell matrix and the shift vectors from the <code class="docutils literal notranslate"><span class="pre">Periodic</span> <span class="pre">Image</span></code> bond property:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bond_vectors</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">pbc_vectors</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>The shift vectors array is transposed here to facilitate the transformation 
of the entire array of vectors with a single 3x3 cell matrix. 
To summarize: In the two code snippets above we have performed 
the following calculation for every bond (<em>a</em>, <em>b</em>) in parallel:</p>
<blockquote>
<div><p>v = x(b) - x(a) + dot(H, pbc)</p>
</div></blockquote>
<p>where <em>H</em> is the cell matrix and <em>pbc</em> is the bond’s PBC shift vector of the form (n\ <sub>x</sub>, n\ <sub>y</sub>, n\ <sub>z</sub>).</p>
<p id="bond-types-list"><strong>Standard bond properties</strong></p>
<p>The following standard properties are defined for bonds:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 28%" />
<col style="width: 12%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property name</p></th>
<th class="head"><p>Python attribute</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Bond Type</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.bond_types" title="ovito.data.Bonds.bond_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_types</span></code></a></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Color</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.colors" title="ovito.data.Bonds.colors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">colors</span></code></a></p></td>
<td><p>float</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Length</span></p></td>
<td></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Periodic Image</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.pbc_vectors" title="ovito.data.Bonds.pbc_vectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc_vectors</span></code></a></p></td>
<td><p>int</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Selection</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.selection" title="ovito.data.Bonds.selection"><code class="xref py py-attr docutils literal notranslate"><span class="pre">selection</span></code></a></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Topology</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.topology" title="ovito.data.Bonds.topology"><code class="xref py py-attr docutils literal notranslate"><span class="pre">topology</span></code></a></p></td>
<td><p>int64</p></td>
<td><p>A, B</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Transparency</span></p></td>
<td></td>
<td><p>float</p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="ovito.data.Bonds.bond_types">
<em class="property">property </em><code class="sig-name descname">bond_types</code><a class="headerlink" href="#ovito.data.Bonds.bond_types" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Bond</span> <span class="pre">Type</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Bonds.colors">
<em class="property">property </em><code class="sig-name descname">colors</code><a class="headerlink" href="#ovito.data.Bonds.colors" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Color</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Bonds.create_bond">
<code class="sig-name descname">create_bond</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pbcvec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Bonds.create_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new bond between two particles <em>a</em> and <em>b</em>, both parameters being indices into the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> list
to which this <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> container belongs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>int</em>) – Index of first particle connected by the new bond. Particle indices start at 0.</p></li>
<li><p><strong>b</strong> (<em>int</em>) – Index of second particle connected by the new bond.</p></li>
<li><p><strong>type</strong> (<em>int</em>) – Optional type ID to be assigned to the new bond. This value will be stored to the <a class="reference internal" href="#ovito.data.Bonds.bond_types" title="ovito.data.Bonds.bond_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_types</span></code></a> array.</p></li>
<li><p><strong>pbcvec</strong> (<em>tuple</em>) – Three integers specifying the bond’s crossings of periodic cell boundaries. The information will be stored in the <a class="reference internal" href="#ovito.data.Bonds.pbc_vectors" title="ovito.data.Bonds.pbc_vectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc_vectors</span></code></a> array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The index of the newly created bond, i.e. <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">(Bonds.count-1)</span></code></a>.</p>
</dd>
</dl>
<p>The method does <em>not</em> check if there already is an existing bond connecting the same pair of particles.</p>
<p>The method does <em>not</em> check if the particle indices <em>a</em> and <em>b</em> do exist. Thus, it is your responsibility to ensure that both indices
are in the range 0 to <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">(Particles.count-1)</span></code></a>.</p>
<p>In case the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> has periodic boundary conditions enabled, and the two particles connected by the bond are located in different periodic images,
make sure you provide the <em>pbcvec</em> argument. It is required so that OVITO does not draw the bond as a direct line from particle <em>a</em> to particle <em>b</em> but as a line passing through
the periodic cell faces. You can use the <a class="reference internal" href="#ovito.data.Particles.delta_vector" title="ovito.data.Particles.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Particles.delta_vector()</span></code></a> function to compute
<em>pbcvec</em> or use the <code class="docutils literal notranslate"><span class="pre">pbc_shift</span></code> vector returned by the <a class="reference internal" href="#ovito.data.CutoffNeighborFinder" title="ovito.data.CutoffNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code></a> utility.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Bonds.pbc_vectors">
<em class="property">property </em><code class="sig-name descname">pbc_vectors</code><a class="headerlink" href="#ovito.data.Bonds.pbc_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Periodic</span> <span class="pre">Image</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Bonds.selection">
<em class="property">property </em><code class="sig-name descname">selection</code><a class="headerlink" href="#ovito.data.Bonds.selection" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Selection</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Bonds.topology">
<em class="property">property </em><code class="sig-name descname">topology</code><a class="headerlink" href="#ovito.data.Bonds.topology" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Topology</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.BondsEnumerator">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">BondsEnumerator</code><a class="headerlink" href="#ovito.data.BondsEnumerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility class that permits efficient iteration over the bonds connected to specific particles.</p>
<p>The constructor takes a <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object as input. 
From the generally unordered list of bonds, the <code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code> will build a lookup table for quick enumeration  
of bonds of particular particles.</p>
<p>All bonds connected to a specific particle can be subsequently visited using the <a class="reference internal" href="#ovito.data.BondsEnumerator.bonds_of_particle" title="ovito.data.BondsEnumerator.bonds_of_particle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bonds_of_particle()</span></code></a> method.</p>
<p>Warning: Do not modify the underlying <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object while the <code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code> is in use. 
Adding or deleting bonds would render the internal lookup table of the <code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code> invalid.</p>
<p><strong>Usage example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="n">BondsEnumerator</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="k">import</span> <span class="n">ComputePropertyModifier</span>

<span class="c1"># Load a dataset containing atoms and bonds.</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s1">&#39;input/bonds.data.gz&#39;</span><span class="p">,</span> <span class="n">atom_style</span><span class="o">=</span><span class="s1">&#39;bond&#39;</span><span class="p">)</span>

<span class="c1"># For demonstration purposes, lets here define a compute modifier that calculates the length </span>
<span class="c1"># of each bond, storing the results in a new bond property named &#39;Length&#39;.</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ComputePropertyModifier</span><span class="p">(</span><span class="n">operate_on</span><span class="o">=</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span> <span class="n">output_property</span><span class="o">=</span><span class="s1">&#39;Length&#39;</span><span class="p">,</span> <span class="n">expressions</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BondLength&#39;</span><span class="p">]))</span>

<span class="c1"># Obtain pipeline results.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span>  <span class="c1"># array with atomic positions</span>
<span class="n">bond_topology</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">topology</span>  <span class="c1"># array with bond topology</span>
<span class="n">bond_lengths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="s1">&#39;Length&#39;</span><span class="p">]</span>     <span class="c1"># array with bond lengths</span>

<span class="c1"># Create bonds enumerator object.</span>
<span class="n">bonds_enum</span> <span class="o">=</span> <span class="n">BondsEnumerator</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>

<span class="c1"># Loop over atoms.</span>
<span class="k">for</span> <span class="n">particle_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
    <span class="c1"># Loop over bonds of current atom.</span>
    <span class="k">for</span> <span class="n">bond_index</span> <span class="ow">in</span> <span class="n">bonds_enum</span><span class="o">.</span><span class="n">bonds_of_particle</span><span class="p">(</span><span class="n">particle_index</span><span class="p">):</span>
        <span class="c1"># Obtain the indices of the two particles connected by the bond:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">bond_topology</span><span class="p">[</span><span class="n">bond_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">bond_topology</span><span class="p">[</span><span class="n">bond_index</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Bond directions can be arbitrary (a-&gt;b or b-&gt;a):</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">particle_index</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="n">particle_index</span><span class="p">)</span>
        
        <span class="c1"># Obtain the length of the bond from the &#39;Length&#39; bond property:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">bond_lengths</span><span class="p">[</span><span class="n">bond_index</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bond from atom </span><span class="si">%i</span><span class="s2"> to atom </span><span class="si">%i</span><span class="s2"> has length </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ovito.data.BondsEnumerator.bonds_of_particle">
<code class="sig-name descname">bonds_of_particle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.BondsEnumerator.bonds_of_particle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator that yields the indices of the bonds connected to the given particle. The indices can be used to index into the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> arrays of the <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.CutoffNeighborFinder">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">CutoffNeighborFinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cutoff</span></em>, <em class="sig-param"><span class="n">data_collection</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility class that computes particle neighbor lists.</p>
<p>This class lets you iterate over all neighbors of a particle that are located within a specified spherical cutoff.
You can use it to build neighbors lists or perform computations that require neighbor vector information.</p>
<p>The constructor takes a positive cutoff radius and a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> 
providing the input particles and the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> (needed for periodic systems).</p>
<p>Once the <code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code> has been constructed, you can call its <a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find" title="ovito.data.CutoffNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method to 
iterate over the neighbors of a particle, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="n">CutoffNeighborFinder</span>

<span class="c1"># Load input simulation file.</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="c1"># Initialize neighbor finder object:</span>
<span class="n">cutoff</span> <span class="o">=</span> <span class="mf">3.5</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">CutoffNeighborFinder</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># Prefetch the property array containing the particle type information:</span>
<span class="n">ptypes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span>

<span class="c1"># Loop over all particles:</span>
<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Neighbors of particle </span><span class="si">%i</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>

    <span class="c1"># Iterate over the neighbors of the current particle:</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">pbc_shift</span><span class="p">)</span>

        <span class="c1"># The index can be used to access properties of the current neighbor, e.g.</span>
        <span class="n">type_of_neighbor</span> <span class="o">=</span> <span class="n">ptypes</span><span class="p">[</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>Note: In case you rather want to determine the <em>N</em> nearest neighbors of a particle,
use the <a class="reference internal" href="#ovito.data.NearestNeighborFinder" title="ovito.data.NearestNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code></a> class instead.</p>
<dl class="py method">
<dt id="ovito.data.CutoffNeighborFinder.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all neighbors of the given particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – The zero-based index of the central particle whose neighbors should be enumerated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A Python iterator that visits all neighbors of the central particle within the cutoff distance. 
For each neighbor the iterator returns an object with the following property fields:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The zero-based global index of the current neighbor particle.</p></li>
<li><p><strong>distance</strong>: The distance of the current neighbor from the central particle.</p></li>
<li><p><strong>distance_squared</strong>: The squared neighbor distance.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector connecting the central particle with the current neighbor (taking into account periodicity).</p></li>
<li><p><strong>pbc_shift</strong>: The periodic shift vector, which specifies how often each periodic boundary of the simulation cell is crossed when going from the central particle to the current neighbor.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>The <cite>index</cite> value returned by the iterator can be used to look up properties of the neighbor particle as demonstrated in the example above.</p>
<p>Note that all periodic images of particles within the cutoff radius are visited. Thus, the same particle index may appear multiple times in the neighbor
list of the central particle. In fact, the central particle may be among its own neighbors in a small periodic simulation cell.
However, the computed vector (<code class="docutils literal notranslate"><span class="pre">delta</span></code>) and PBC shift (<code class="docutils literal notranslate"><span class="pre">pbc_shift</span></code>) will be unique for each visited image of the neighbor particle.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.CutoffNeighborFinder.find_at">
<code class="sig-name descname">find_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coords</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.find_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all particles located within the spherical range of the given center position. In contrast to <a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find" title="ovito.data.CutoffNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> this method can search for neighbors around arbitrary 
spatial locations, which don’t have to coincide with any physical particle position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coords</strong> – A (x,y,z) coordinate triplet specifying the center location around which to search for particles.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A Python iterator enumerating all particles within the cutoff distance. 
For each neighbor the iterator returns an object with the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The zero-based global index of the current neighbor particle.</p></li>
<li><p><strong>distance</strong>: The distance of the current particle from the center position.</p></li>
<li><p><strong>distance_squared</strong>: The squared distance.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector from the center to the current neighbor (taking into account periodicity).</p></li>
<li><p><strong>pbc_shift</strong>: The periodic shift vector, which specifies how often each periodic boundary of the simulation cell is crossed when going from the center point to the current neighbor.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>The index value returned by the iterator can be used to look up properties of the neighbor particle as demonstrated in the example above.</p>
<p>Note that all periodic images of particles within the cutoff radius are visited. Thus, the same particle index may appear multiple times in the neighbor list. 
However, the computed vector (<code class="docutils literal notranslate"><span class="pre">delta</span></code>) and image offset (<code class="docutils literal notranslate"><span class="pre">pbc_shift</span></code>) will be unique for each visited image of a neighbor particle.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.CutoffNeighborFinder.neighbor_distances">
<code class="sig-name descname">neighbor_distances</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.neighbor_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of distances between some central particle and all its neighbors within the cutoff range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – The 0-based index of the central particle whose neighbors should be enumerated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NumPy array containg the radial distances to all neighbor particles within the cutoff range (in arbitrary order).</p>
</dd>
</dl>
<p>This method is equivalent to the following code, but performance is typically better:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbor_distances</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.CutoffNeighborFinder.neighbor_vectors">
<code class="sig-name descname">neighbor_vectors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.neighbor_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of vectors from some central particle to all its neighbors within the cutoff range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – The 0-based index of the central particle whose neighbors should be enumerated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Two-dimensional NumPy array containg the vectors to all neighbor particles within the cutoff range (in arbitrary order).</p>
</dd>
</dl>
<p>The method is equivalent to the following code, but performance is typically better:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbor_vectors</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="n">vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.DataCollection">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">DataCollection</code><a class="headerlink" href="#ovito.data.DataCollection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code> is a container class holding together individual <em>data objects</em>, each representing different fragments of a dataset. For example, a dataset loaded from a simulation data file may consist of particles, the simulation cell information and additional auxiliary data such as the current timestep number of the snaphots, etc. All this information is contained in one <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code>, which exposes the individual pieces of information as sub-objects, for example via the <a class="reference internal" href="#ovito.data.DataCollection.particles" title="ovito.data.DataCollection.particles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.particles</span></code></a>, <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.cell</span></code></a> and <a class="reference internal" href="#ovito.data.DataCollection.attributes" title="ovito.data.DataCollection.attributes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.attributes</span></code></a> fields.</p>
<p>Data collections are the elementary entities that get processed within a data <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>. Each modifier receives a data collection from the preceding modifier, alters it in some way, and passes it on to the next modifier. The output data collection of the last modifier in the pipeline is returned by the <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline.compute" title="ovito.pipeline.Pipeline.compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Pipeline.compute()</span></code></a> method.</p>
<p>A data collection essentially consists of a bunch of <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObjects</span></code></a>, which are all stored in the <a class="reference internal" href="#ovito.data.DataCollection.objects" title="ovito.data.DataCollection.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.objects</span></code></a> list. Typically, you don’t access the data objects through this list directly but rather use on of the special accessor fields provided by the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code> class, which give more convenient access to data objects of a particular kind. For example, the <a class="reference internal" href="#ovito.data.DataCollection.surfaces" title="ovito.data.DataCollection.surfaces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">surfaces</span></code></a> dictionary provides key-based access to all the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> instances currently in the data collection.</p>
<p>You can programmatically add or remove data objects from a data collection by manipulating its <a class="reference internal" href="#ovito.data.DataCollection.objects" title="ovito.data.DataCollection.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a> list. For instance, to populate a new data collection instance that is initially empty with a new <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">DataCollection</span><span class="p">()</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">SimulationCell</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ovito.data.DataCollection.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">modifier</span></em>, <em class="sig-param"><span class="n">frame</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataCollection.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>This method applies a <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Modifier" title="ovito.pipeline.Modifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Modifier</span></code></a> function to the data in this collection in place.</p>
<p>It allows modifying a data collection with one of Ovito’s built-in modifiers directly without the need to build up a complete
<a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> first. In contrast to a data pipeline, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> method
executes the modifier function immediately and changes the input data in place. In other words, the original data in this <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>
will be replaced by the output produced by the invoked modifier function. Note that it is possible to create a copy of
the original data collection using the <a class="reference internal" href="#ovito.data.DataCollection.clone" title="ovito.data.DataCollection.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> method if needed. The following code example
demonstrates how to use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> method to successively modify the state of a dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="k">import</span> <span class="o">*</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">CoordinationAnalysisModifier</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="mf">2.9</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ExpressionSelectionModifier</span><span class="p">(</span><span class="n">expression</span><span class="o">=</span><span class="s2">&quot;Coordination&lt;9&quot;</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">DeleteSelectedModifier</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that it is typically possible to achieve the same result by first populating a <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> with the modifiers and then calling its
<a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline.compute" title="ovito.pipeline.Pipeline.compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute()</span></code></a> method at the very end:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CoordinationAnalysisModifier</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="mf">2.9</span><span class="p">))</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExpressionSelectionModifier</span><span class="p">(</span><span class="n">expression</span><span class="o">=</span><span class="s2">&quot;Coordination&lt;9&quot;</span><span class="p">))</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DeleteSelectedModifier</span><span class="p">())</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
<p>Also note that <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> may be called from a user-defined modifier function (see <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.PythonScriptModifier" title="ovito.modifiers.PythonScriptModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">PythonScriptModifier</span></code></a>)
in order to invoke a built-in modifier as a sub-routine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># A user-defined modifier function that calls the built-in ColorCodingModifier</span>
<span class="c1"># as a sub-routine to assign a color to each atom based on some property</span>
<span class="c1"># created within the function itself:</span>
<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;idx&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ColorCodingModifier</span><span class="p">(</span><span class="nb">property</span><span class="o">=</span><span class="s1">&#39;idx&#39;</span><span class="p">),</span> <span class="n">frame</span><span class="p">)</span>

<span class="c1"># Set up a data pipeline that uses the user-defined modifier function:</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modify</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>modifier</strong> – The <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Modifier" title="ovito.pipeline.Modifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Modifier</span></code></a> that will be called by the method to alter the data in place.</p></li>
<li><p><strong>frame</strong> (<em>int</em>) – An optional animation frame number that will be passed to the modifier function, which may use it to implement time-dependent modifications.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.attributes">
<em class="property">property </em><code class="sig-name descname">attributes</code><a class="headerlink" href="#ovito.data.DataCollection.attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>This field contains a dictionary view with all the <em>global attributes</em> currently associated with this data collection.
Global attributes are key-value pairs that represent small tokens of information, typically simple value types such as <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">str</span></code>. 
Every attribute has a unique identifier such as <code class="docutils literal notranslate"><span class="pre">'Timestep'</span></code> or <code class="docutils literal notranslate"><span class="pre">'ConstructSurfaceMesh.surface_area'</span></code>. This identifier serves as look-up key in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">attributes</span></code> dictionary.
Attributes are dynamically generated by modifiers in a data pipeline or come from the data source.
For example, if the input simulation file contains timestep information, the timestep number is made available by the <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.FileSource" title="ovito.pipeline.FileSource"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FileSource</span></code></a> as the
<code class="docutils literal notranslate"><span class="pre">'Timestep'</span></code> attribute. It can be retrieved from pipeline’s output data collection:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s1">&#39;snapshot_140000.dump&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;Timestep&#39;</span><span class="p">]</span>
<span class="go">140000</span>
</pre></div>
</div>
<p>Some modifiers report their calculation results by adding new attributes to the data collection. See each modifier’s
reference documentation for the list of attributes it generates. For example, the number of clusters identified by the
<a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ClusterAnalysisModifier" title="ovito.modifiers.ClusterAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterAnalysisModifier</span></code></a> is available in the pipeline output as an attribute named
<code class="docutils literal notranslate"><span class="pre">ClusterAnalysis.cluster_count</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ClusterAnalysisModifier</span><span class="p">(</span><span class="n">cutoff</span> <span class="o">=</span> <span class="mf">3.1</span><span class="p">))</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="n">nclusters</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;ClusterAnalysis.cluster_count&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">ovito.io.export_file()</span></code></a> function can be used to output dynamically computed attributes to a text file, possibly as functions of time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s2">&quot;data.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;txt/attr&quot;</span><span class="p">,</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Timestep&quot;</span><span class="p">,</span> <span class="s2">&quot;ClusterAnalysis.cluster_count&quot;</span><span class="p">],</span>
    <span class="n">multiple_frames</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>If you are writing your own <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">modifier function</span></a>, you let it add new attributes to a data collection.
In the following example, the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CommonNeighborAnalysisModifier" title="ovito.modifiers.CommonNeighborAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommonNeighborAnalysisModifier</span></code></a> first inserted into the
pipeline generates the <code class="docutils literal notranslate"><span class="pre">'CommonNeighborAnalysis.counts.FCC'</span></code> attribute to report the number of atoms that
have an FCC-like coordination. To compute an atomic <em>fraction</em> from that, we need to divide the count by the total number of
atoms in the system. To this end, we append a user-defined modifier function
to the pipeline, which computes the fraction and outputs the value as a new attribute named <code class="docutils literal notranslate"><span class="pre">'fcc_fraction'</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CommonNeighborAnalysisModifier</span><span class="p">())</span>
            
<span class="k">def</span> <span class="nf">compute_fcc_fraction</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">n_fcc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;CommonNeighborAnalysis.counts.FCC&#39;</span><span class="p">]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;fcc_fraction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_fcc</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span>

<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_fcc_fraction</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;fcc_fraction&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.cell">
<em class="property">property </em><code class="sig-name descname">cell</code><a class="headerlink" href="#ovito.data.DataCollection.cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object, which stores the cell vectors and periodic boundary
condition flags, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there is no cell information associated with this data collection.</p>
<p>Note: The <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> data object may be read-only if it is currently shared by
several data collections. Use the <code class="xref py py-attr docutils literal notranslate"><span class="pre">cell_</span></code> field instead to request a mutable cell object 
if you intend to modify it.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataCollection.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> containing the same data objects as the original.</p>
<p>The method may be used to retain a copy of the original data before modifying a data collection in place,
for example using the <a class="reference internal" href="#ovito.data.DataCollection.apply" title="ovito.data.DataCollection.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">original</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ExpressionSelectionModifier</span><span class="p">(</span><span class="n">expression</span><span class="o">=</span><span class="s2">&quot;Position.Z &lt; 0&quot;</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">DeleteSelectedModifier</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of atoms before:&quot;</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of atoms after:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the <code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code> method performs an inexpensive, shallow copy, meaning that the newly created collection will still share
the data objects with the original collection. Data objects that are shared by two or more data collections are
protected against modification by default to avoid unwanted side effects.
Thus, in order to subsequently modify the data objects in either the original collection or its
copy, you will have to use the underscore notation or the <a class="reference internal" href="#ovito.data.DataObject.make_mutable" title="ovito.data.DataObject.make_mutable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataObject.make_mutable()</span></code></a> method to explicitly
request a deep copy of the particular data object(s) you want to modify. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">copy</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
<span class="c1"># Data objects are shared by original and copy:</span>
<span class="k">assert</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

<span class="c1"># In order to modify the SimulationCell in the dataset copy, we must request</span>
<span class="c1"># a mutable version of the SimulationCell using the &#39;cell_&#39; accessor:</span>
<span class="n">copy</span><span class="o">.</span><span class="n">cell_</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># As a result, the cell object in the second data collection has been replaced</span>
<span class="c1"># with a deep copy and the two data collections no longer share the same</span>
<span class="c1"># simulation cell object:</span>
<span class="k">assert</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.dislocations">
<em class="property">property </em><code class="sig-name descname">dislocations</code><a class="headerlink" href="#ovito.data.DataCollection.dislocations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a> data object from this data collection or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there isn’t one.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.grids">
<em class="property">property </em><code class="sig-name descname">grids</code><a class="headerlink" href="#ovito.data.DataCollection.grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary view providing key-based access to all <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrids</span></code></a> in 
this data collection. Each <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key, 
which you can use to look it up in this dictionary. To find out which voxel grids exist in the data collection and what 
their identifier keys are, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">grids</span><span class="p">)</span>
</pre></div>
</div>
<p>Then retrieve the desired <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> from the collection using its identifier key, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">charge_density_grid</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="s1">&#39;charge-density&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">charge_density_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.objects">
<em class="property">property </em><code class="sig-name descname">objects</code><a class="headerlink" href="#ovito.data.DataCollection.objects" title="Permalink to this definition">¶</a></dt>
<dd><p>The unordered list of all <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObjects</span></code></a> stored in this data collection. You can add or remove data objects in this list as needed.</p>
<p>Note that typically you don’t have to work with this list directly, because the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code> class provides several convenience accessor fields for the different flavors of objects in this mixed list. For example, the <a class="reference internal" href="#ovito.data.DataCollection.particles" title="ovito.data.DataCollection.particles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.particles</span></code></a> field returns the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object from this data objects list. Also, dictionary views such as <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a> provide key-based access to a particular class of data objects from this list.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.particles">
<em class="property">property </em><code class="sig-name descname">particles</code><a class="headerlink" href="#ovito.data.DataCollection.particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object from this data collection, which stores the particle properties and -as a sub-object- the 
<a class="reference internal" href="#ovito.data.Particles.bonds" title="ovito.data.Particles.bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bonds</span></code></a> between particles. <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned if the data collection does not contain any particle data.</p>
<p>Note that the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object may be marked as read-only if it is currently shared by several data collections.
If you intend to modify the particles container or its sub-objects in any way, e.g. add, remove or modify particle properties, 
you must request a mutable version of the particles object using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">particles_</span></code> accessor instead.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.surfaces">
<em class="property">property </em><code class="sig-name descname">surfaces</code><a class="headerlink" href="#ovito.data.DataCollection.surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary view providing key-based access to all <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> objects in 
this data collection. Each <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key, 
which can be used to look it up in the dictionary. 
See the documentation of the modifier producing the surface mesh to find out what the right key is, or use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="p">)</span>
</pre></div>
</div>
<p>to see which identifier keys exist. Then retrieve the desired <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> object from the collection using its identifier 
key, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.tables">
<em class="property">property </em><code class="sig-name descname">tables</code><a class="headerlink" href="#ovito.data.DataCollection.tables" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary view of all <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> objects in
this data collection. Each <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key, 
which can be used to look it up in this dictionary. You can use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="p">)</span>
</pre></div>
</div>
<p>to find out which table identifiers exist in the dictionary. Modifiers that generate a data table typically 
assign a predefined identifier, which can be found in their documentation.
Use the key string to retrieve the desired <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> from the dictionary, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rdf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="s1">&#39;coordination-rdf&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rdf</span><span class="o">.</span><span class="n">xy</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataCollection.trajectories">
<em class="property">property </em><code class="sig-name descname">trajectories</code><a class="headerlink" href="#ovito.data.DataCollection.trajectories" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.TrajectoryLines" title="ovito.data.TrajectoryLines"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryLines</span></code></a> object, which holds the continuous particle trajectories traced 
by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.GenerateTrajectoryLinesModifier" title="ovito.modifiers.GenerateTrajectoryLinesModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateTrajectoryLinesModifier</span></code></a>. 
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned if the data collection does not contain a <a class="reference internal" href="#ovito.data.TrajectoryLines" title="ovito.data.TrajectoryLines"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryLines</span></code></a> object.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.DataObject">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">DataObject</code><a class="headerlink" href="#ovito.data.DataObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for all data object types in OVITO.</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code> represents a fragment of data processed in or by a data pipeline. 
See the <a class="reference internal" href="#module-ovito.data" title="ovito.data"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ovito.data</span></code></a> module for a list of different concrete data object types in OVITO. 
Data objects are typically contained in a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>, 
which represents a whole <em>data set</em>. Furthermore, data objects can be nested into hierarchy. 
For example, the <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> data object is part of the parent <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> data object.</p>
<p>Data objects by themselves are non-visual objects. Visualizing the information stored in a data object in images 
is the responsibility of so-called <a class="reference internal" href="../introduction/rendering.html#rendering-visual-elements"><span class="std std-ref">visual elements</span></a>.
A data object may be associated with a <a class="reference internal" href="ovito_vis.html#ovito.vis.DataVis" title="ovito.vis.DataVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataVis</span></code></a> element by assigning it to the data object’s <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> field. 
Each type of visual element exposes a set of parameters that allow you to configure the appearance of the 
data visualization in rendered images and animations.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../introduction/data_model.html#data-model-intro"><span class="std std-ref">Data model</span></a></p>
<p><a class="reference internal" href="../introduction/rendering.html#rendering-visual-elements"><span class="std std-ref">Visual elements</span></a></p>
</div>
<dl class="py method">
<dt id="ovito.data.DataObject.identifier">
<em class="property">property </em><code class="sig-name descname">identifier</code><a class="headerlink" href="#ovito.data.DataObject.identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique identifier string of the data object. It serves as look-up key in object dictionaries, for example the <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a> collection, or as a target name in various places where a data object needs to be referenced by name, e.g. the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.TimeAveragingModifier.operate_on" title="ovito.modifiers.TimeAveragingModifier.operate_on"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TimeAveragingModifier.operate_on</span></code></a> field.</p>
<p>Data objects generated by modifiers in a pipeline typically have an automatically assigned identifier, as documented in the description of the respective modifier. When writing your own <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">modifier function</span></a>, you are responsible for giving new data objects created by your modifier function a meaningful identifier, so that subsequent modifiers in the pipeline can refer to these data objects.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataObject.make_mutable">
<code class="sig-name descname">make_mutable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">subobj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataObject.make_mutable" title="Permalink to this definition">¶</a></dt>
<dd><p>This helper method requests a deep copy of <em>subobj</em>, which must be a child <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code> of this parent <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code>. A copy will only be made in case the sub-object is currently referenced by at least one more parent object. If, however, the sub-object is exclusive owned by this <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code>, no copy is made and the original sub-object is returned as is. The returned object is safe to modify without unexpected side effects, because any shared ownership is converted an exclusive ownership by the method.</p>
<p>Please see the section <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">Announcing object modification</span></a> for a discussion of object ownership and typical use-cases for this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>subobj</strong> (<a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><em>DataObject</em></a>) – A existing sub-object of this parent data object, for which exclusive ownership is requested.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A copy of <em>subobj</em> if its ownership was previously shared with some other parent. Otherwise the original object is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataObject.vis">
<em class="property">property </em><code class="sig-name descname">vis</code><a class="headerlink" href="#ovito.data.DataObject.vis" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="ovito_vis.html#ovito.vis.DataVis" title="ovito.vis.DataVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataVis</span></code></a> element currently associated with this data object, which is responsible for visually rendering the stored data. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the data object remains non-visual and doesn’t appear in rendered images or the viewports. Furthermore, note that the same <a class="reference internal" href="ovito_vis.html#ovito.vis.DataVis" title="ovito.vis.DataVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataVis</span></code></a> element may be assigned to multiple data objects in order to synchronize their visual appearance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.DataTable">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">DataTable</code><a class="headerlink" href="#ovito.data.DataTable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
</dd>
</dl>
<p>This data object type represents a series of data points and is used for generating histogram plots and other 2d data graphs. 
A <a class="reference internal" href="../introduction/data_model.html#data-tables-intro"><span class="std std-ref">data table</span></a> consists of an array of y-values and, optionally, an array of corresponding x-values, one for each data point. 
Both arrays are standard <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> objects managed by the data table, which is a <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> 
subclass.</p>
<p>If the <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> data array is not present, the x-coordinates of the data points are implicitly determined by the table’s
<a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>, which specifies a value range along the x-axis over which the data points are evenly distributed. 
This is used, for example, for histograms having equisized bins.</p>
<p>Data tables generated by modifiers such as <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CoordinationAnalysisModifier" title="ovito.modifiers.CoordinationAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinationAnalysisModifier</span></code></a> and <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.HistogramModifier" title="ovito.modifiers.HistogramModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistogramModifier</span></code></a>
are accessible through the <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a> dictionary of the data collection.
Please see the documentation of a modifier to find out what data table(s) it produces.</p>
<p><strong>Examples:</strong></p>
<p>The following code examples demonstrate how to create a new <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code> and
fill it with data values in Python. You can use these techniques, for instance, to write <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">custom modifier functions</span></a> 
that output their results as data plots in OVITO.</p>
<p>To create a simple x-y scatter point plot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a DataTable object, setting the title and plot type:</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">DataTable</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Scatter Plot&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Scatter</span><span class="p">)</span>
<span class="c1"># Set the x- and y-coordinates of the data points:</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;X coordinates&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Y coordinates&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
<span class="c1"># Add the DataTable to the output DataCollection:</span>
<span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how the <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> method is used here to create two <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a>
objects holding the x- and y-coordinates of the data points. These property objects are then set as <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> and <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> arrays
of the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code>.</p>
<p>Generating a graph with several line plots requires creating a <em>vector</em> property object for the <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> array of the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">DataTable</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Trigonometric functions&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Line</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Parameter x&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="c1"># Use the x-coords to compute two y-coords per data point: y(x) = (cos(x), sin(x)) </span>
<span class="n">y1y2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;f(x)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">y1y2</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cos(x)&#39;</span><span class="p">,</span> <span class="s1">&#39;sin(x)&#39;</span><span class="p">])</span>
<span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
<p>To generate a bar chart, the <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property must be filled with numeric IDs 0,1,2,3,… denoting the individual bars. 
Each bar is then assigned a text label by creating a <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> instance and adding it to the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">DataTable</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Bar Chart&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">BarChart</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Structure Type&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ElementType</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Other&#39;</span><span class="p">))</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ElementType</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FCC&#39;</span><span class="p">))</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ElementType</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;HCP&#39;</span><span class="p">))</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ElementType</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BCC&#39;</span><span class="p">))</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">75</span><span class="p">])</span>
<span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
<p>For histogram plots, one can specify the complete range of values covered by the histogram by setting the table’s <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a> property. 
The bin counts must be assigned to the table’s <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> property. The number of elements in the <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> property array, together with the
<a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>, determine the number of histogram bins and their width:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">DataTable</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Histogram&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Histogram</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Counts&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">75</span><span class="p">])</span>
<span class="n">table</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>   <span class="c1"># Four histogram bins of width 0.5 each.</span>
<span class="n">table</span><span class="o">.</span><span class="n">axis_label_x</span> <span class="o">=</span> <span class="s1">&#39;Values&#39;</span> <span class="c1"># Set the x-axis label of the plot.</span>
<span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
<p>If you are going to refer to the data table after it has been inserted into the <a class="reference internal" href="#ovito.data.DataCollection.objects" title="ovito.data.DataCollection.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.objects</span></code></a>
list, you should give it a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> at construction time, as shown in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">DataTable</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;trig-func&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Plot&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Line</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;X coords&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
    <span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Y coords&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">frame</span> <span class="o">*</span> <span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modify</span><span class="p">)</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s1">&#39;output/data.*.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;txt/table&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;trig-func&#39;</span><span class="p">,</span> <span class="n">multiple_frames</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">user-defined modifier function</span></a> outputs a table to the data pipeline having the 
<a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> <code class="docutils literal notranslate"><span class="pre">'trig-func'</span></code>. When <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_file()</span></code></a> is called later with the export 
file format <code class="docutils literal notranslate"><span class="pre">'txt/table'</span></code>, the table identifier must be specified as extra argument <code class="docutils literal notranslate"><span class="pre">key</span></code> to select the right data table to export.
Furthermore, the table’s identifier may be used as lookup key to retreive the table from the <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tables</span></code></a> dictionary view
of a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>.</p>
<dl class="py method">
<dt id="ovito.data.DataTable.axis_label_x">
<em class="property">property </em><code class="sig-name descname">axis_label_x</code><a class="headerlink" href="#ovito.data.DataTable.axis_label_x" title="Permalink to this definition">¶</a></dt>
<dd><p>The text label of the x-axis. This string is only used for a data plot if the <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property of the data table is <code class="docutils literal notranslate"><span class="pre">None</span></code> and the x-coordinates of the data points are implicitly defined by the table’s <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a> property. Otherwise the <a class="reference internal" href="#ovito.data.Property.name" title="ovito.data.Property.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> of the <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property is used as axis label.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataTable.interval">
<em class="property">property </em><code class="sig-name descname">interval</code><a class="headerlink" href="#ovito.data.DataTable.interval" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of float values specifying the x-axis interval covered by the data points in this table.
This interval is only used by the table if the data points do not possess explicit x-coordinates (i.e. if the table’s <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property is <code class="docutils literal notranslate"><span class="pre">None</span></code>).
In the absence of explicit x-coordinates, the interval specifies the range of equispaced x-coordinates implicitly generated
by the data table.</p>
<p>Implicit x-coordinates are typically used in data tables representing histograms, which consist of equally-sized bins
covering a certain value range along the x-axis. The bin size is then given by the interval width divided by the
number of data points (see <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PropertyContainer.count</span></code></a> property). The implicit x-coordinates of data points are placed in the centers of the bins. 
You can call the table’s <a class="reference internal" href="#ovito.data.DataTable.xy" title="ovito.data.DataTable.xy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">xy()</span></code></a> method to let it explicitly calculate the x-coordinates from the value interval for every data point.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataTable.plot_mode">
<em class="property">property </em><code class="sig-name descname">plot_mode</code><a class="headerlink" href="#ovito.data.DataTable.plot_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of graphical plot for rendering the data in this <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code>. Must be one of the following predefined constants:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.NoPlot</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Line</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Histogram</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.BarChart</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Scatter</span></code></p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Line</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataTable.x">
<em class="property">property </em><code class="sig-name descname">x</code><a class="headerlink" href="#ovito.data.DataTable.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> containing the x-coordinates of the data points. The data points may not have explicit x-coordinates, so this property may be <code class="docutils literal notranslate"><span class="pre">None</span></code> for a data table. In such a case, the x-coordinates of the data points are implicitly determined by the table’s <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataTable.xy">
<code class="sig-name descname">xy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataTable.xy" title="Permalink to this definition">¶</a></dt>
<dd><p>This convenience method returns a two-dimensional NumPy array containing both the x- and the y-coordinates of the data points in this data table.
If the data table does not contain explicit <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> coordinates, this method will
automatically compute the x-coordinates from the <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DataTable.y">
<em class="property">property </em><code class="sig-name descname">y</code><a class="headerlink" href="#ovito.data.DataTable.y" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> containing the y-coordinates of the data points. This may be a vector property having more than one component per data point, in which case this data table represents a family of data plots.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.DislocationNetwork">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">DislocationNetwork</code><a class="headerlink" href="#ovito.data.DislocationNetwork" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>This data object stores the network of dislocation lines extracted by a <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.DislocationAnalysisModifier" title="ovito.modifiers.DislocationAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationAnalysisModifier</span></code></a>. You can access it through the <a class="reference internal" href="#ovito.data.DataCollection.dislocations" title="ovito.data.DataCollection.dislocations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.dislocations</span></code></a> field.</p>
<p>The dislocation network is associated with a <a class="reference internal" href="ovito_vis.html#ovito.vis.DislocationVis" title="ovito.vis.DislocationVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationVis</span></code></a> element controlling the visual appearance of the dislocation lines. It can be accessed through the <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> attribute of the <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a> base class.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span><span class="p">,</span> <span class="n">export_file</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="k">import</span> <span class="n">DislocationAnalysisModifier</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="n">DislocationNetwork</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>

<span class="c1"># Extract dislocation lines from a crystal with diamond structure:</span>
<span class="n">modifier</span> <span class="o">=</span> <span class="n">DislocationAnalysisModifier</span><span class="p">()</span>
<span class="n">modifier</span><span class="o">.</span><span class="n">input_crystal_structure</span> <span class="o">=</span> <span class="n">DislocationAnalysisModifier</span><span class="o">.</span><span class="n">Lattice</span><span class="o">.</span><span class="n">CubicDiamond</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modifier</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="n">total_line_length</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;DislocationAnalysis.total_line_length&#39;</span><span class="p">]</span>
<span class="n">cell_volume</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;DislocationAnalysis.cell_volume&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dislocation density: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">total_line_length</span> <span class="o">/</span> <span class="n">cell_volume</span><span class="p">))</span>

<span class="c1"># Print list of dislocation lines:</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%i</span><span class="s2"> dislocation segments&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">segments</span><span class="p">))</span>
<span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Segment </span><span class="si">%i</span><span class="s2">: length=</span><span class="si">%f</span><span class="s2">, Burgers vector=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">segment</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">segment</span><span class="o">.</span><span class="n">true_burgers_vector</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

<span class="c1"># Export dislocation lines to a CA file:</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s2">&quot;output/dislocations.ca&quot;</span><span class="p">,</span> <span class="s2">&quot;ca&quot;</span><span class="p">)</span>

<span class="c1"># Or export dislocations to a ParaView VTK file:</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s2">&quot;output/dislocations.vtk&quot;</span><span class="p">,</span> <span class="s2">&quot;vtk/disloc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>File export</strong></p>
<p>A dislocation network can be written to a data file in the form of polylines using the <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">ovito.io.export_file()</span></code></a> function (select the <code class="docutils literal notranslate"><span class="pre">vtk/disloc</span></code> output format). During export, a non-periodic version is produced by clipping dislocation lines at the domain boundaries.</p>
<dl class="py method">
<dt id="ovito.data.DislocationNetwork.segments">
<em class="property">property </em><code class="sig-name descname">segments</code><a class="headerlink" href="#ovito.data.DislocationNetwork.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of dislocation segments in this dislocation network. This list-like object is read-only and contains <a class="reference internal" href="#ovito.data.DislocationSegment" title="ovito.data.DislocationSegment"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationSegment</span></code></a> objects.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationNetwork.set_segment">
<code class="sig-name descname">set_segment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em>, <em class="sig-param"><span class="n">true_burgers_vector</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cluster_id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">points</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">custom_color</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DislocationNetwork.set_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows you to change the data fields of individual dislocation lines. Fields for which no new value is specified will keep their current values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> – The zero-based index of the dislocation line in the <a class="reference internal" href="#ovito.data.DislocationNetwork.segments" title="ovito.data.DislocationNetwork.segments"><code class="xref py py-attr docutils literal notranslate"><span class="pre">segments</span></code></a> array to be modified.</p></li>
<li><p><strong>true_burgers_vector</strong> – The lattice-space Burgers vector (<a class="reference internal" href="#ovito.data.DislocationSegment.true_burgers_vector" title="ovito.data.DislocationSegment.true_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">true_burgers_vector</span></code></a>) to be assigned to the dislocation line.</p></li>
<li><p><strong>cluster_id</strong> – The numeric ID of the crystallite cluster the dislocation line is embedded in.</p></li>
<li><p><strong>points</strong> – A <em>N</em> x 3 NumPy array with the Cartesian coordinates of the dislocation line vertices.</p></li>
<li><p><strong>custom_color</strong> – RGB color to be used for rendering the line instead of the automically determined color.</p></li>
</ul>
</dd>
</dl>
<p>Example of a <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">user-defined modifier function</span></a> manipulating the dislocation line data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="c1"># Flip Burgers vector and line sense of each dislocation:</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">dislocations_</span><span class="o">.</span><span class="n">set_segment</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> 
            <span class="n">true_burgers_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">true_burgers_vector</span><span class="p">),</span> 
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>

    <span class="c1"># Highlight all 1/6[121] dislocations in a red color:</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">true_burgers_vector</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">)):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">dislocations_</span><span class="o">.</span><span class="n">set_segment</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">custom_color</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.DislocationSegment">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">DislocationSegment</code><a class="headerlink" href="#ovito.data.DislocationSegment" title="Permalink to this definition">¶</a></dt>
<dd><p>A single dislocation line from a <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a>.</p>
<p>The list of dislocation segments is returned by the <a class="reference internal" href="#ovito.data.DislocationNetwork.segments" title="ovito.data.DislocationNetwork.segments"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DislocationNetwork.segments</span></code></a> attribute.</p>
<dl class="py method">
<dt id="ovito.data.DislocationSegment.cluster_id">
<em class="property">property </em><code class="sig-name descname">cluster_id</code><a class="headerlink" href="#ovito.data.DislocationSegment.cluster_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The numeric identifier of the crystal cluster of atoms containing this dislocation segment.</p>
<p>The true Burgers vector of the segment is expressed in the local coordinate system of this crystal cluster.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.custom_color">
<em class="property">property </em><code class="sig-name descname">custom_color</code><a class="headerlink" href="#ovito.data.DislocationSegment.custom_color" title="Permalink to this definition">¶</a></dt>
<dd><p>The RGB color value to be used for visualizing this particular dislocation line, overriding the default coloring scheme imposed by the <a class="reference internal" href="ovito_vis.html#ovito.vis.DislocationVis.indicate_character" title="ovito.vis.DislocationVis.indicate_character"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DislocationVis.indicate_character</span></code></a> mode setting. The custom color is only used if its RGB components are non-negative (i.e. in the range 0-1); otherwise the line will be rendered using the computed color depending on the line’s Burgers vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(-1.0,</span> <span class="pre">-1.0,</span> <span class="pre">-1.0)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.id">
<em class="property">property </em><code class="sig-name descname">id</code><a class="headerlink" href="#ovito.data.DislocationSegment.id" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique identifier of this dislocation segment.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.is_infinite_line">
<em class="property">property </em><code class="sig-name descname">is_infinite_line</code><a class="headerlink" href="#ovito.data.DislocationSegment.is_infinite_line" title="Permalink to this definition">¶</a></dt>
<dd><p>This property indicates whether this segment is an infinite line passing through a periodic simulation box boundary. A segment is considered infinite if it is a closed loop and its start and end points do not coincide.</p>
<p>See also the <a class="reference internal" href="#ovito.data.DislocationSegment.is_loop" title="ovito.data.DislocationSegment.is_loop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_loop</span></code></a> property.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.is_loop">
<em class="property">property </em><code class="sig-name descname">is_loop</code><a class="headerlink" href="#ovito.data.DislocationSegment.is_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>This property indicates whether this segment forms a closed dislocation loop. Note that an infinite dislocation line passing through a periodic boundary is also considered a loop.</p>
<p>See also the <a class="reference internal" href="#ovito.data.DislocationSegment.is_infinite_line" title="ovito.data.DislocationSegment.is_infinite_line"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_infinite_line</span></code></a> property.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.length">
<em class="property">property </em><code class="sig-name descname">length</code><a class="headerlink" href="#ovito.data.DislocationSegment.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the length of this dislocation segment.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.points">
<em class="property">property </em><code class="sig-name descname">points</code><a class="headerlink" href="#ovito.data.DislocationSegment.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of space points that define the shape of this dislocation segment. This is a <em>N</em> x 3 Numpy array, where <em>N</em> is the number of points along the segment. For closed loops, the first and the last point coincide.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.spatial_burgers_vector">
<em class="property">property </em><code class="sig-name descname">spatial_burgers_vector</code><a class="headerlink" href="#ovito.data.DislocationSegment.spatial_burgers_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>The Burgers vector of the segment, expressed in the global coordinate system of the simulation. This vector is calculated by transforming the true Burgers vector from the local lattice coordinate system to the global simulation coordinate system using the average orientation matrix of the crystal cluster the dislocation segment is embedded in.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.DislocationSegment.true_burgers_vector">
<em class="property">property </em><code class="sig-name descname">true_burgers_vector</code><a class="headerlink" href="#ovito.data.DislocationSegment.true_burgers_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>The Burgers vector of the segment, expressed in the local coordinate system of the crystal. Also known as the True Burgers vector.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.ElementType">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">ElementType</code><a class="headerlink" href="#ovito.data.ElementType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>Describes a single type of elements, for example a particular atom or bond type. A <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> object can store a set of element types in its <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code> is the base class for some specialized element types in OVITO:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> (used with typed properties in a <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> container)</p></li>
<li><p><a class="reference internal" href="#ovito.data.BondType" title="ovito.data.BondType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondType</span></code></a> (used with typed properties in a <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> container)</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt id="ovito.data.ElementType.color">
<em class="property">property </em><code class="sig-name descname">color</code><a class="headerlink" href="#ovito.data.ElementType.color" title="Permalink to this definition">¶</a></dt>
<dd><p>The display color used for rendering elements of this type. This is a tuple with RGB values in the range 0 to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(1.0,</span> <span class="pre">1.0,</span> <span class="pre">1.0)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ElementType.enabled">
<em class="property">property </em><code class="sig-name descname">enabled</code><a class="headerlink" href="#ovito.data.ElementType.enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag only has a meaning in the context of structure analysis and identification. Modifiers such as the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.PolyhedralTemplateMatchingModifier" title="ovito.modifiers.PolyhedralTemplateMatchingModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyhedralTemplateMatchingModifier</span></code></a> or the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CommonNeighborAnalysisModifier" title="ovito.modifiers.CommonNeighborAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommonNeighborAnalysisModifier</span></code></a> manage a list of structural types that they can identify (e.g. FCC, BCC, etc.). The identification of individual structure types can be turned on or off by setting their <code class="xref py py-attr docutils literal notranslate"><span class="pre">enabled</span></code> flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ElementType.id">
<em class="property">property </em><code class="sig-name descname">id</code><a class="headerlink" href="#ovito.data.ElementType.id" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique numeric identifier of the type (typically a positive <code class="docutils literal notranslate"><span class="pre">int</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ElementType.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#ovito.data.ElementType.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The display name of this type. If this string is empty, the numeric <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a> will be used when referring to this type.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.NearestNeighborFinder">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">NearestNeighborFinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">data_collection</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.NearestNeighborFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility class that finds the <em>N</em> nearest neighbors of a particle or around a spatial location.</p>
<p>The constructor takes the (maximum) number of requested nearest neighbors, <em>N</em>, and a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>
containing the input particles and the cell geometry (including periodic boundary flags).
<em>N</em> must be a positive integer not greater than 30 (which is the built-in maximum supported by this class).</p>
<p>Once the <code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code> has been constructed, you can call its <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find" title="ovito.data.NearestNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method to
iterate over the sorted list of nearest neighbors of a specific particle, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="n">NearestNeighborFinder</span>

<span class="c1"># Load input simulation file.</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="c1"># Initialize neighbor finder object.</span>
<span class="c1"># Visit the 12 nearest neighbors of each particle.</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">NearestNeighborFinder</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># Prefetch the property array containing the particle type information:</span>
<span class="n">ptypes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span>

<span class="c1"># Loop over all input particles:</span>
<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nearest neighbors of particle </span><span class="si">%i</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
    <span class="c1"># Iterate over the neighbors of the current particle, starting with the closest:</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="c1"># The index can be used to access properties of the current neighbor, e.g.</span>
        <span class="n">type_of_neighbor</span> <span class="o">=</span> <span class="n">ptypes</span><span class="p">[</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>Furthermore, the class offers the <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find_at" title="ovito.data.NearestNeighborFinder.find_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_at()</span></code></a> method, which lets you determine the <em>N</em> nearest particles around an
arbitrary spatial location:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find particles closest to some spatial point (x,y,z):</span>
<span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_at</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: In case you rather want to find all neighbor particles within a certain cutoff range of a particle,
use the <a class="reference internal" href="#ovito.data.CutoffNeighborFinder" title="ovito.data.CutoffNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code></a> class instead.</p>
<dl class="py method">
<dt id="ovito.data.NearestNeighborFinder.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.NearestNeighborFinder.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator that visits the <em>N</em> nearest neighbors of the given particle in order of ascending distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – The index of the central particle whose neighbors should be iterated. Particle indices start at 0.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A Python iterator that visits the <em>N</em> nearest neighbors of the central particle in order of ascending distance.
For each visited neighbor the iterator returns an object with the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The global index of the current neighbor particle.</p></li>
<li><p><strong>distance</strong>: The distance of the current neighbor from the central particle.</p></li>
<li><p><strong>distance_squared</strong>: The squared neighbor distance.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector connecting the central particle with the current neighbor (correctly taking into account periodic boundary conditions).</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>The global index returned by the iterator can be used to look up properties of the neighbor as demonstrated in the first example code above.</p>
<p>Note that several periodic images of the same particle may be visited if the periodic simulation cell is sufficiently small.
Then the same particle index may appear more than once in the neighbor list. In fact, the central particle may be among its own neighbors in a sufficiently small periodic simulation cell.
However, the computed neighbor vector (<code class="docutils literal notranslate"><span class="pre">delta</span></code>) will be unique for each image of a neighboring particle.</p>
<p>The number of neighbors actually visited may be smaller than the requested number, <em>N</em>, if the
system contains too few particles and has no periodic boundary conditions.</p>
<p>Note that the <code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code> method will not find other particles located exactly at the same spatial position as the central particle for technical reasons.
To find such particles too, which are positioned exactly on top of each other, make use of the <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find_at" title="ovito.data.NearestNeighborFinder.find_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_at()</span></code></a> method instead.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.NearestNeighborFinder.find_at">
<code class="sig-name descname">find_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coords</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.NearestNeighborFinder.find_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator that visits the <em>N</em> nearest particles around a spatial point given by <em>coords</em> in order of ascending distance.
Unlike the <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find" title="ovito.data.NearestNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method, which queries the nearest neighbors of a physical particle, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_at()</span></code> method allows
searching for neareby particles at arbitrary locations in space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coords</strong> – A (x,y,z) coordinate triplet specifying the spatial location where the <em>N</em> nearest particles should be queried.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A Python iterator that visits the <em>N</em> nearest neighbors in order of ascending distance.
For each visited particle the iterator returns an object with the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The index of the current particle (starting at 0).</p></li>
<li><p><strong>distance</strong>: The distance of the current neighbor from the query location.</p></li>
<li><p><strong>distance_squared</strong>: The squared distance to the query location.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector from the query point to the current particle (correctly taking into account periodic boundary conditions).</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>If there exists a particle that is exactly located at the query location given by <em>coords</em>, then it will be returned by this function.
This is in contrast to the <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find" title="ovito.data.NearestNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> function, which does not visit the central particle itself.</p>
<p>The number of neighbors actually visited may be smaller than the requested number, <em>N</em>, if the
system contains too few particles and has no periodic boundary conditions.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.ParticleType">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">ParticleType</code><a class="headerlink" href="#ovito.data.ParticleType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.ElementType</span></code></a></p>
</dd>
</dl>
<p>This data object describes one particle or atom type. In atomistic simulations, each chemical element is typically represented by an instance of
the <code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code> class. The property fields of the class control how the particles of that type get visualized in terms of e.g. color, particle radius, shape, etc.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code> class inherits several general data fields from its base class <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a>, e.g. the <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">color</span></code></a>, <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>
and <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a> fields. It adds specific fields for particles: <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> and <a class="reference internal" href="#ovito.data.ParticleType.shape" title="ovito.data.ParticleType.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a>. Furthermore, the class has additional
fields controlling the visual appearance of particles with user-defined shapes.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code> instances are all stored in the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> object with the name <code class="docutils literal notranslate"><span class="pre">'Particle</span> <span class="pre">Type'</span></code>, which also stores for each particle what
its type is. The association between particles and particle types is established via a unique numeric type <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a>. The following code shows how to iterate over
all particle types in a dataset, which are listed in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> field of the <a class="reference internal" href="#ovito.data.Particles.particle_types" title="ovito.data.Particles.particle_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">particle_types</span></code></a> property:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Access the property with the name &#39;Particle Type&#39;:</span>
<span class="n">prop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span>

<span class="c1"># Print list of particle types (their numeric IDs and names)</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">prop</span><span class="o">.</span><span class="n">types</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ID </span><span class="si">{}</span><span class="s1"> -&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

<span class="c1"># Print the numeric type ID of each particle:</span>
<span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">prop</span><span class="p">[</span><span class="o">...</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
</pre></div>
</div>
<p>The order in which the particle types are stored in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list is arbitrary, and the unique numeric IDs of particle types have no specific meaning in general.
A common operation is to find the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> in the list corresponding to a given numeric ID. For this look up operation, the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> class provides the <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_id()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Look up the particle type with unique ID 2:</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">type_by_id</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>

<span class="c1"># Iterate over all particles and print their type&#39;s name:</span>
<span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">prop</span><span class="p">[</span><span class="o">...</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">type_by_id</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>Another common operation is to look up a particle type by name, for example the type representing a certain chemical element. 
For this kind of look up operation, the <a class="reference internal" href="#ovito.data.Property.type_by_name" title="ovito.data.Property.type_by_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_name()</span></code></a> method may be used, which assumes that each type has a unique <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> (which may not always be true):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print numeric ID of particle type &#39;Si&#39;:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">type_by_name</span><span class="p">(</span><span class="s1">&#39;Si&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ovito.data.ParticleType.backface_culling">
<em class="property">property </em><code class="sig-name descname">backface_culling</code><a class="headerlink" href="#ovito.data.ParticleType.backface_culling" title="Permalink to this definition">¶</a></dt>
<dd><p>Activates back-face culling for the user-defined particle shape mesh to speed up rendering. If turned on, polygonal sides of the shape mesh facing away from the viewer will not be rendered. You can turn this option off if the particle’s shape is not closed and two-sided rendering is required. This option only has an effect if a user-defined shape has been assigned to the particle type using the <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ParticleType.highlight_edges">
<em class="property">property </em><code class="sig-name descname">highlight_edges</code><a class="headerlink" href="#ovito.data.ParticleType.highlight_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Activates the highlighting of the polygonal edges of the user-defined particle shape during rendering. This option only has an effect if a user-defined shape has been assigned to the particle type using the <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ParticleType.load_defaults">
<code class="sig-name descname">load_defaults</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.ParticleType.load_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the type’s chemical <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>, which must have been set before calling this method, initializes the type’s <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">color</span></code></a> and <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> fields with default values from OVITO’s internal database of chemical elements. This method is useful when creating new atom types while building up a molecule structure.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ParticleType.load_shape">
<code class="sig-name descname">load_shape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.ParticleType.load_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a user-defined shape to the particle type. Particles of this type will subsequently be rendered using the polyhedral mesh loaded from the given file. The method will automatically detect the format of the geometry file and supports standard file formats such as OBJ, STL and VTK that contain triangle meshes, see <a class="reference external" href="./../../file_formats.input.html">this table</a>.</p>
<p>The shape loaded from the geometry file will be scaled with the <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> value set for this particle type or the per-particle value stored in the <code class="docutils literal notranslate"><span class="pre">Radius</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a> if present. The shape of each particle will be rendered such that its origin is located at the coordinates of the particle.</p>
<p>The following example script demonstrates how to load a user-defined shape for the first particle type (index 0) loaded from a LAMMPS dump file, which can be accessed through the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list of the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_scene</span><span class="p">()</span>

<span class="n">types</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span>
<span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">load_shape</span><span class="p">(</span><span class="s2">&quot;input/tetrahedron.vtk&quot;</span><span class="p">)</span>
<span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">highlight_edges</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ParticleType.mass">
<em class="property">property </em><code class="sig-name descname">mass</code><a class="headerlink" href="#ovito.data.ParticleType.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>The mass of this particle type.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0.0</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ParticleType.radius">
<em class="property">property </em><code class="sig-name descname">radius</code><a class="headerlink" href="#ovito.data.ParticleType.radius" title="Permalink to this definition">¶</a></dt>
<dd><p>This property controls the display size of the particles of this type.</p>
<p>When set to zero, particles of this type will be rendered using the standard size specified by the <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis.radius" title="ovito.vis.ParticlesVis.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticlesVis.radius</span></code></a> parameter. Furthermore, precedence is given to any per-particle sizes assigned to the <code class="docutils literal notranslate"><span class="pre">Radius</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a> if that property has been defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0.0</span></code></p>
</dd>
</dl>
<p>The following example script demonstrates how to set the display radii of two particle types loaded from a simulation file, which can be accessed through the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list of the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_scene</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">setup_particle_types</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Cu&quot;</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.35</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Zr&quot;</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.55</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setup_particle_types</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ParticleType.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#ovito.data.ParticleType.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects the geometric shape used when rendering particles of this type. Supported modes are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Unspecified</span></code> (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Sphere</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Box</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Circle</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Square</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Cylinder</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Spherocylinder</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Mesh</span></code></p></li>
</ul>
</div></blockquote>
<p>By default, the standard particle shape that is set in the <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis.shape" title="ovito.vis.ParticlesVis.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticlesVis</span></code></a> visual element is used to render particles of this type. Parameter values other than <code class="docutils literal notranslate"><span class="pre">Unspecified</span></code> allow you to control the rendering shape on a per-type basis. Mode <code class="docutils literal notranslate"><span class="pre">Sphere</span></code> includes ellipsoid and superquadric particle shapes, which are enabled by the presence of the <code class="docutils literal notranslate"><span class="pre">Aspherical</span> <span class="pre">Shape</span></code> and <code class="docutils literal notranslate"><span class="pre">Superquadric</span> <span class="pre">Roundness</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle properties</span></a>.</p>
<p>The <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method lets you specify a user-defined mesh geometry for this particle type. Calling this method automatically switches the shape parameter to mode <code class="docutils literal notranslate"><span class="pre">Mesh</span></code>.</p>
<p>Setting the shapes of particle types permanently, i.e., for all frames of a loaded simulation trajectory, typically requires a user-defined modifier function. This function is inserted into the <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> to make the necessary changes to the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> objects associated with the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> named <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.vis</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Load a simulation file containing numeric particle types 1, 2, 3, ...</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/nylon.data&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_scene</span><span class="p">()</span>

<span class="c1"># Set the default particle shape in the ParticlesVis visual element, </span>
<span class="c1"># which will be used by all particle types for which we do not specify a different shape below.</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ParticlesVis</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">Box</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1"># A user-defined modifier function that configures the shapes of particle types 1 and 2:</span>
<span class="k">def</span> <span class="nf">setup_particle_types</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span> 
    <span class="c1"># Write access to property &#39;Particle Type&#39;:</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span>  
    <span class="c1"># Write access to numeric ParticleTypes, which are sub-objects of the Property object:</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ParticlesVis</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">Cylinder</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.2</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ParticlesVis</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">Sphere</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setup_particle_types</span><span class="p">)</span>

<span class="c1"># Render a picture of the 3d scene:</span>
<span class="n">vp</span> <span class="o">=</span> <span class="n">Viewport</span><span class="p">(</span><span class="n">camera_dir</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">vp</span><span class="o">.</span><span class="n">zoom_all</span><span class="p">()</span>
<span class="n">vp</span><span class="o">.</span><span class="n">render_image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;output/particles.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span> <span class="n">renderer</span><span class="o">=</span><span class="n">TachyonRenderer</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.ParticleType.use_mesh_color">
<em class="property">property </em><code class="sig-name descname">use_mesh_color</code><a class="headerlink" href="#ovito.data.ParticleType.use_mesh_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the intrinsic mesh color(s) instead of the particle color when rendering particles of this type. This option only has an effect if a user-defined shape has been assigned to the particle type using the <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.Particles">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">Particles</code><a class="headerlink" href="#ovito.data.Particles" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
</dd>
</dl>
<p>This container object stores the information associated with a system of particles. 
It is typically accessed through the <a class="reference internal" href="#ovito.data.DataCollection.particles" title="ovito.data.DataCollection.particles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.particles</span></code></a> 
field of a data collection. 
The current number of particles is given by the <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> attribute 
that is inherited from the <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class. 
The particles may be associated with a set of properties. Each property is represented by a 
<a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data object, that is stored in this property container and is basically an 
array of numeric values of length <em>N</em>, where <em>N</em> is the number of particles in the system. 
Each property array has a unique name, by which it can be looked up through the dictionary interface of the 
<a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class. 
While the user is free to define arbitrary particle properties, OVITO predefines a set of <em>standard properties</em> 
that each have a fixed data layout, meaning and name. They are listed in the table below.</p>
<table class="docutils align-default" id="particle-properties-list">
<colgroup>
<col style="width: 54%" />
<col style="width: 11%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Standard property name</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Angular Momentum</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Angular Velocity</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Aspherical Shape</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Centrosymmetry</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Charge</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Cluster</span></p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Color</span></p></td>
<td><p>float</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Coordination</span></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Deformation Gradient</span></p></td>
<td><p>float</p></td>
<td><p>XX, YX, ZX, XY, YY, ZY, XZ, YZ, ZZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Dipole Magnitude</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Dipole Orientation</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Displacement Magnitude</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Displacement</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">DNA Strand</span></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Elastic Deformation Gradient</span></p></td>
<td><p>float</p></td>
<td><p>XX, YX, ZX, XY, YY, ZY, XZ, YZ, ZZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Elastic Strain</span></p></td>
<td><p>float</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Force</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Kinetic Energy</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Mass</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Molecule Identifier</span></p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Molecule Type</span></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Nucleobase</span></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Nucleotide Axis</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Nucleotide Normal</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Orientation</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z, W</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Particle Identifier</span></p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Particle Type</span></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Periodic Image</span></p></td>
<td><p>int</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Position</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Potential Energy</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Radius</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Rotation</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z, W</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Selection</span></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Spin</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Strain Tensor</span></p></td>
<td><p>float</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Stress Tensor</span></p></td>
<td><p>float</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Stretch Tensor</span></p></td>
<td><p>float</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Structure Type</span></p></td>
<td><p>int</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Superquadric Roundness</span></p></td>
<td><p>float</p></td>
<td><p>Phi, Theta</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Torque</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Total Energy</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Transparency</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Vector Color</span></p></td>
<td><p>float</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Velocity Magnitude</span></p></td>
<td><p>float</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Velocity</span></p></td>
<td><p>float</p></td>
<td><p>X, Y, Z</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="ovito.data.Particles.angles">
<em class="property">property </em><code class="sig-name descname">angles</code><a class="headerlink" href="#ovito.data.Particles.angles" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the list of angles defined for the molecular model (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.bonds">
<em class="property">property </em><code class="sig-name descname">bonds</code><a class="headerlink" href="#ovito.data.Particles.bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> data object storing the list of bonds and their properties (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.colors">
<em class="property">property </em><code class="sig-name descname">colors</code><a class="headerlink" href="#ovito.data.Particles.colors" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Color</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.create_particle">
<code class="sig-name descname">create_particle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">position</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Particles.create_particle" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new particle to the particle system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>position</strong> (<em>tuple</em>) – The xyz coordinates for the new particle.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The index of the newly created particle, i.e. <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">(Particles.count-1)</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.delta_vector">
<code class="sig-name descname">delta_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">return_pbcvec</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Particles.delta_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the vector connecting two particles <em>a</em> and <em>b</em> in a periodic simulation cell by applying the minimum image convention.</p>
<p>This is a convenience wrapper for the <a class="reference internal" href="#ovito.data.SimulationCell.delta_vector" title="ovito.data.SimulationCell.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SimulationCell.delta_vector()</span></code></a> method,
which computes the vector between two arbitrary spatial locations <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span> taking into account periodic
boundary conditions. The version of the method described here takes two particle indices <em>a</em> and <em>b</em> as input, computing the shortest vector
<span class="math notranslate nohighlight">\({\Delta} = (r_b - r_a)\)</span> between them using the <a class="reference external" href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">minimum image convention</a>.
Please see the <a class="reference internal" href="#ovito.data.SimulationCell.delta_vector" title="ovito.data.SimulationCell.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SimulationCell.delta_vector()</span></code></a> method for further information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Zero-based index of the first input particle. This may also be an array of particle indices.</p></li>
<li><p><strong>b</strong> – Zero-based index of the second input particle. This may also be an array of particle indices with the same length as <em>a</em>.</p></li>
<li><p><strong>cell</strong> – The <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object that defines the periodic domain. Typically, <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.cell</span></code></a> is used here.</p></li>
<li><p><strong>return_pbcvec</strong> (<em>bool</em>) – If True, also returns the vector <span class="math notranslate nohighlight">\(n\)</span>, which specifies how often the computed particle-to-particle vector crosses the cell’s face.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The delta vector and, optionally, the vector <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.dihedrals">
<em class="property">property </em><code class="sig-name descname">dihedrals</code><a class="headerlink" href="#ovito.data.Particles.dihedrals" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the list of dihedrals defined for the molecular model (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.forces">
<em class="property">property </em><code class="sig-name descname">forces</code><a class="headerlink" href="#ovito.data.Particles.forces" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Force</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.identifiers">
<em class="property">property </em><code class="sig-name descname">identifiers</code><a class="headerlink" href="#ovito.data.Particles.identifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Identifier</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.impropers">
<em class="property">property </em><code class="sig-name descname">impropers</code><a class="headerlink" href="#ovito.data.Particles.impropers" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the list of impropers defined for the molecular model (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.masses">
<em class="property">property </em><code class="sig-name descname">masses</code><a class="headerlink" href="#ovito.data.Particles.masses" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Mass</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.particle_types">
<em class="property">property </em><code class="sig-name descname">particle_types</code><a class="headerlink" href="#ovito.data.Particles.particle_types" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.positions">
<em class="property">property </em><code class="sig-name descname">positions</code><a class="headerlink" href="#ovito.data.Particles.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Position</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.selection">
<em class="property">property </em><code class="sig-name descname">selection</code><a class="headerlink" href="#ovito.data.Particles.selection" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Selection</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.structure_types">
<em class="property">property </em><code class="sig-name descname">structure_types</code><a class="headerlink" href="#ovito.data.Particles.structure_types" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Structure</span> <span class="pre">Type</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Particles.velocities">
<em class="property">property </em><code class="sig-name descname">velocities</code><a class="headerlink" href="#ovito.data.Particles.velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Velocity</span></code> standard particle property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.Property">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">Property</code><a class="headerlink" href="#ovito.data.Property" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>Stores the property values for an array of data elements (e.g. particles, bonds or voxels).</p>
<p>Each property, for example a particle property, is represented by one <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> object storing the property values for all particles. Thus, a <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> object is basically an array of values whose length matches the number of data elements.</p>
<p>All <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> objects belonging to the same class of data elements, for example all particle properties, are managed by a <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>. In the case of particle properties, the corresponding container class is the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> class, which is a specialization of the generic <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class.</p>
<p><strong>Data access</strong></p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> object behaves like a Numpy array. For example, you can access the property value for the <em>i</em>-th data element using indexing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Position of first particle:&#39;</span><span class="p">,</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Z-coordinate of second particle:&#39;</span><span class="p">,</span> <span class="n">positions</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span> 
    <span class="nb">print</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
</pre></div>
</div>
<p>Element indices start at zero. Properties can be either vectorial (e.g. velocity vectors are stored as an <em>N</em> x 3 array) or scalar (1-d array of length <em>N</em>). The length of the first array dimension is in both cases equal to the number of data elements (number of particles in the example above). Array elements can either be of data type <code class="docutils literal notranslate"><span class="pre">float64</span></code>, <code class="docutils literal notranslate"><span class="pre">int32</span></code> or <code class="docutils literal notranslate"><span class="pre">int64</span></code>.</p>
<p>If you want to modify the per-element values in a property array, make sure you are working with a modifiable version of the array by employing the <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">underscore notation</span></a>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modifiable_positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="p">[</span><span class="s1">&#39;Position_&#39;</span><span class="p">]</span>
<span class="n">modifiable_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Typed properties</strong></p>
<p>The standard particle property <code class="docutils literal notranslate"><span class="pre">'Particle</span> <span class="pre">Type'</span></code> stores the types of particles encoded as integer values, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tprop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Particle Type&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tprop</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>
<span class="go">[2 1 3 ..., 2 1 2]</span>
</pre></div>
</div>
<p>Here, each number in the property array refers to one of the particle types (e.g. 1=Cu, 2=Ni, 3=Fe, etc.). The defined particle types, each one represented by an instance of the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> auxiliary class, are stored in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> array of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code>. Each type has a unique <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a>, a human-readable <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> and other attributes like <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">color</span></code></a> and <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> that control the visual appearance of particles belonging to the type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">tprop</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">type</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="nb">type</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">1 Cu (0.188 0.313 0.972) 0.74</span>
<span class="go">2 Ni (0.564 0.564 0.564) 0.77</span>
<span class="go">3 Fe (1 0.050 0.050) 0.74</span>
</pre></div>
</div>
<p>IDs of types typically start at 1 and form a consecutive sequence as in the example above. Note, however, that the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list may store the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> objects in an arbitrary order. Thus, in general, it is not valid to directly use a type ID as an index into the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> array. Instead, the <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_id()</span></code></a> method should be used to look up the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tprop</span><span class="p">):</span> <span class="c1"># (loop over the type ID of each particle)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Atom&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;is of type&#39;</span><span class="p">,</span> <span class="n">tprop</span><span class="o">.</span><span class="n">type_by_id</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Atom 0 is of type Ni</span>
<span class="go">Atom 1 is of type Cu</span>
<span class="go">Atom 2 is of type Fe</span>
<span class="go">Atom 3 is of type Cu</span>
</pre></div>
</div>
<p>Similarly, a <a class="reference internal" href="#ovito.data.Property.type_by_name" title="ovito.data.Property.type_by_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_name()</span></code></a> method exists that looks up a <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticleType</span></code></a> by name. For example, to count the number of Fe atoms in a system:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Fe_type_id</span> <span class="o">=</span> <span class="n">tprop</span><span class="o">.</span><span class="n">type_by_name</span><span class="p">(</span><span class="s1">&#39;Fe&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">id</span>   <span class="c1"># Determine ID of the &#39;Fe&#39; type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">tprop</span> <span class="o">==</span> <span class="n">Fe_type_id</span><span class="p">)</span>   <span class="c1"># Count particles having that type ID</span>
<span class="go">957</span>
</pre></div>
</div>
<p>Note that OVITO supports multiple type classifications. For example, in addition to the <code class="docutils literal notranslate"><span class="pre">'Particle</span> <span class="pre">Type'</span></code> standard particle property, which stores the chemical types of atoms (e.g. C, H, Fe, …), the <code class="docutils literal notranslate"><span class="pre">'Structure</span> <span class="pre">Type'</span></code> property may hold the structural types computed for atoms (e.g. FCC, BCC, …) maintaining its own list of known structure types in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> array.</p>
<dl class="py method">
<dt id="ovito.data.Property.component_count">
<em class="property">property </em><code class="sig-name descname">component_count</code><a class="headerlink" href="#ovito.data.Property.component_count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of vector components if this is a vector property; or 1 if this is a scalar property.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Property.component_names">
<em class="property">property </em><code class="sig-name descname">component_names</code><a class="headerlink" href="#ovito.data.Property.component_names" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of names of the vector components if this is a vector property. For example, for the <code class="docutils literal notranslate"><span class="pre">Position</span></code> particle property this field contains <code class="docutils literal notranslate"><span class="pre">['X',</span> <span class="pre">'Y',</span> <span class="pre">'Z']</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Property.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#ovito.data.Property.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the property.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Property.type_by_id">
<code class="sig-name descname">type_by_id</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">id</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Property.type_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks up the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> with the given numeric ID in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.
Raises a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> if no type with the numeric ID exists.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Property.type_by_name">
<code class="sig-name descname">type_by_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Property.type_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks up the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> with the given name in the property’s <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.
If multiple types exists with the same name, the first type is returned. 
Raises a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> if there is no type with such a name.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.Property.types">
<em class="property">property </em><code class="sig-name descname">types</code><a class="headerlink" href="#ovito.data.Property.types" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> instances attached to this property.</p>
<p>Note that the element types may be stored in arbitrary order in this list. Thus, it is not valid to use a numeric type ID as an index into this list.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.PropertyContainer">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">PropertyContainer</code><a class="headerlink" href="#ovito.data.PropertyContainer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>A dictionary-like object storing a set of <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> objects.</p>
<p>It implements the <code class="docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code> interface. That means it can be used like a standard read-only Python <code class="docutils literal notranslate"><span class="pre">dict</span></code> object to access the properties by name, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span>
<span class="n">has_selection</span> <span class="o">=</span> <span class="s1">&#39;Selection&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span>
<span class="n">name_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>New properties can be added with the <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> method as described <a class="reference internal" href="../introduction/data_manipulation.html#creating-new-properties"><span class="std std-ref">here</span></a>.</p>
<p>OVITO provides several concrete implementations of the abstract <code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code> base class:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a></p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt id="ovito.data.PropertyContainer.count">
<em class="property">property </em><code class="sig-name descname">count</code><a class="headerlink" href="#ovito.data.PropertyContainer.count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of data elements in this container, e.g. the number of particles. This value is always equal to the lengths of the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> arrays managed by this container.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.PropertyContainer.create_property">
<code class="sig-name descname">create_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">components</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.PropertyContainer.create_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new property to the container and optionally initializes it with
the per-element data provided by the <em>data</em> parameter. The method returns the new <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a>
instance.</p>
<p>The method allows to create <em>standard</em> as well as <em>user-defined</em> properties.
To create a <em>standard</em> property, one of the <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">standard property names</span></a> must be provided as <em>name</em> argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Color&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
</pre></div>
</div>
<p>The length of the provided <em>data</em> array must match the number of existing elements in the container, which is given by the <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> attribute.
You can alternatively assign the per-element values to the property after its construction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Color&#39;</span><span class="p">)</span>
<span class="n">prop</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a <em>user-defined</em> property, use a non-standard property name:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;myint&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case the data type and the number of vector components of the new property are inferred from
the provided <em>data</em> Numpy array. Providing a one-dimensional array creates a scalar property while
a two-dimensional array creates a vectorial property.
Alternatively, the <em>dtype</em> and <em>components</em> parameters can be specified explicitly
if you are going to assign the property values at a later time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;myvector&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">prop</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>If the property to be created already exists in the container, it is replaced with a new one.
The existing per-element data from the old property is however retained if <em>data</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Note: If the container contains no properties yet, then the number of elements (e.g. particles or bonds) is still undefined.
In this case the <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code> method lets you <em>define</em> the number of elements when inserting the very first property
by specifying a <em>data</em> array of the desired length. For example, to create a new <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> container from scratch
with 10 particles, a Numpy array of length 10 is used to initialize the <code class="docutils literal notranslate"><span class="pre">Position</span></code> particle property:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># An empty Particles container to begin with:</span>
<span class="n">particles</span> <span class="o">=</span> <span class="n">Particles</span><span class="p">()</span>

<span class="c1"># Create 10 particles with random xyz coordinates:</span>
<span class="n">xyz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">particles</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Position&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
</pre></div>
</div>
<p>After the initial <code class="docutils literal notranslate"><span class="pre">Positions</span></code> property has been created, the number of particles in the container is now determined and any
subsequently added properties must have the exact same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Either a <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">standard property type constant</span></a> or a name string.</p></li>
<li><p><strong>data</strong> – An optional data array with per-element values for initializing the new property.
The size of the array must match the element <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> of the container
and the shape must be consistent with the number of components of the property to be created.</p></li>
<li><p><strong>dtype</strong> – The element data type when creating a user-defined property. Must be either <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p></li>
<li><p><strong>components</strong> (<em>int</em>) – The number of vector components when creating a user-defined property.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The newly created <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.PropertyContainer.delete_elements">
<code class="sig-name descname">delete_elements</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.PropertyContainer.delete_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a subset of the elements from this container. The elements to be deleted must be specified in terms
of a 1-dimensional mask array having the same length as the container (see <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a>).
The method will delete those elements whose corresponding mask value is non-zero, i.e., the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th element 
will be deleted if <code class="docutils literal notranslate"><span class="pre">mask[i]!=0</span></code>.</p>
<p>For example, to delete all currently selected particles, i.e., the subset of particles whose <code class="docutils literal notranslate"><span class="pre">Selection</span></code> property 
is non-zero, one would simply write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">delete_elements</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Selection&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The effect of this statement is the same as for applying the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.DeleteSelectedModifier" title="ovito.modifiers.DeleteSelectedModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeleteSelectedModifier</span></code></a> to the particles list.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.PropertyContainer.delete_indices">
<code class="sig-name descname">delete_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.PropertyContainer.delete_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a subset of the elements from this container. The elements to be deleted must be specified in terms
of a sequence of indices, all in the range 0 to <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a>-1. The method accepts any type of iterable object,
including sequence types and generators.</p>
<p>For example, to delete every other particle, one could use Python’s <code class="docutils literal notranslate"><span class="pre">range()</span></code> function to generate
all even indices up to the length of the particle container:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">delete_indices</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.PropertyContainer.title">
<em class="property">property </em><code class="sig-name descname">title</code><a class="headerlink" href="#ovito.data.PropertyContainer.title" title="Permalink to this definition">¶</a></dt>
<dd><p>The title of the data object under which it appears in the user interface of OVITO.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.SimulationCell">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">SimulationCell</code><a class="headerlink" href="#ovito.data.SimulationCell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>Stores the geometric shape and the boundary conditions of the simulation cell. A <code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code> data object is typically part of a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> and can be retrieved through its <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="c1"># Print cell matrix to the console. [...] is for casting to Numpy array.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>The simulation cell geometry is stored as a 3x4 matrix (with column-major ordering). The first three columns of the matrix represent the three cell vectors and the last column is the position of the cell’s origin. For two-dimensional datasets, the <a class="reference internal" href="#ovito.data.SimulationCell.is2D" title="ovito.data.SimulationCell.is2D"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is2D</span></code></a> flag ist set. In this case the third cell vector and the z-coordinate of the cell origin are ignored by OVITO in many computations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute simulation box volume by taking the determinant of the</span>
<span class="c1"># left 3x3 submatrix of the cell matrix:</span>
<span class="n">vol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>

<span class="c1"># The SimulationCell.volume property yields the same value.</span>
<span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">vol</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code> object behaves like a standard Numpy array of shape (3,4). When modifying the values of the cell matrix, make sure you use the <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">underscore notation</span></a> to request a modifiable version of the <code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make cell twice as large along the Y direction by scaling the second cell vector:</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code> is always associated with a <a class="reference internal" href="ovito_vis.html#ovito.vis.SimulationCellVis" title="ovito.vis.SimulationCellVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCellVis</span></code></a> element, which controls the visual appearance of the simulation box in rendered images. It can be accessed as <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> attribute of the cell, inherited from the <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a> base class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Change display color of simulation cell to red:</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">rendering_color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ovito.data.SimulationCell.delta_vector">
<code class="sig-name descname">delta_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ra</span></em>, <em class="sig-param"><span class="n">rb</span></em>, <em class="sig-param"><span class="n">return_pbcvec</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SimulationCell.delta_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the correct vector connecting points <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span> in a periodic simulation cell by applying the minimum image convention.</p>
<p>The method starts by computing the 3d vector <span class="math notranslate nohighlight">\({\Delta} = r_b - r_a\)</span> for two points <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span>, which may be located in different images
of the periodic simulation cell. The <a class="reference external" href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">minimum image convention</a>
is then applied to obtain the new vector <span class="math notranslate nohighlight">\({\Delta'} = r_b' - r_a\)</span>, where the original point <span class="math notranslate nohighlight">\(r_b\)</span> has been replaced by the periodic image
<span class="math notranslate nohighlight">\(r_b'\)</span> that is closest to <span class="math notranslate nohighlight">\(r_a\)</span>, making the vector <span class="math notranslate nohighlight">\({\Delta'}\)</span> as short as possible (in reduced coordinate space).
<span class="math notranslate nohighlight">\(r_b'\)</span> is obtained by translating <span class="math notranslate nohighlight">\(r_b\)</span> an integer number of times along each of the three cell directions:
<span class="math notranslate nohighlight">\(r_b' = r_b - H*n\)</span>, with <span class="math notranslate nohighlight">\(H\)</span> being the 3x3 cell matrix and <span class="math notranslate nohighlight">\(n\)</span> being a vector of three integers that are chosen by the
method such that <span class="math notranslate nohighlight">\(r_b'\)</span> is as close to <span class="math notranslate nohighlight">\(r_a\)</span> as possible.</p>
<p>Note that the periodic image convention is applied only along those cell directions for which
periodic boundary conditions are enabled (see <a class="reference internal" href="#ovito.data.SimulationCell.pbc" title="ovito.data.SimulationCell.pbc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc</span></code></a> property). For other directions
no shifting is performed, i.e., the corresponding components of <span class="math notranslate nohighlight">\(n = (n_x,n_y,n_z)\)</span> will always be zero.</p>
<p>The method is able to compute the results for either an individual pair of input points or for two <em>arrays</em> of input points. In the latter case,
i.e. if the input parameters <em>ra</em> and <em>rb</em> are both 2-D arrays of shape <em>Nx3</em>, the method returns a 2-D array containing
<em>N</em> output vectors. This allows applying the minimum image convention to a large number of point pairs in one function call.</p>
<p>The optional <em>return_pbcvec</em> flag makes the method return as an additional output the vector <span class="math notranslate nohighlight">\(n\)</span> introduced above.
The components of this vector specify the number of times the image point <span class="math notranslate nohighlight">\(r_b'\)</span> needs to be shifted along each of the three cell directions
in order to bring it onto the original input point <span class="math notranslate nohighlight">\(r_b\)</span>. In other words, it specifies the number of times the
computed vector <span class="math notranslate nohighlight">\({\Delta} = r_b - r_a\)</span> crosses a periodic boundary of the cell (either in positive or negative direction).
For example, the PBC shift vector <span class="math notranslate nohighlight">\(n = (1,0,-2)\)</span> would indicate that, in order to get from input point <span class="math notranslate nohighlight">\(r_a\)</span> to input point <span class="math notranslate nohighlight">\(r_b\)</span>, one has to cross the
cell boundaries once in the positive x-direction and twice in the negative z-direction. If <em>return_pbcvec</em> is True,
the method returns the tuple (<span class="math notranslate nohighlight">\({\Delta'}\)</span>, <span class="math notranslate nohighlight">\(n\)</span>); otherwise it returns just <span class="math notranslate nohighlight">\({\Delta'}\)</span>.
Note that the vector <span class="math notranslate nohighlight">\(n\)</span> computed by this method can be used, for instance, to correctly initialize the <a class="reference internal" href="#ovito.data.Bonds.pbc_vectors" title="ovito.data.Bonds.pbc_vectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Bonds.pbc_vectors</span></code></a>
property for newly created bonds that cross a periodic cell boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra</strong> – The Cartesian xyz coordinates of the first input point(s). Either a 1-D array of length 3 or a 2-D array of shape (<em>N</em>,3).</p></li>
<li><p><strong>rb</strong> – The Cartesian xyz coordinates of the second input point(s). Must have the same shape as <em>ra</em>.</p></li>
<li><p><strong>return_pbcvec</strong> (<em>bool</em>) – If True, also returns the vector <span class="math notranslate nohighlight">\(n\)</span>, which specifies how often the vector <span class="math notranslate nohighlight">\((r_b'r - r_a)\)</span> crosses the periodic cell boundaries.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The vector <span class="math notranslate nohighlight">\({\Delta'}\)</span> and, optionally, the vector <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
</dl>
<p>Note that there exists also a convenience method <a class="reference internal" href="#ovito.data.Particles.delta_vector" title="ovito.data.Particles.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Particles.delta_vector()</span></code></a>,
which should be used in cases where <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span> are both positions of particles in the simulation cell.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SimulationCell.is2D">
<em class="property">property </em><code class="sig-name descname">is2D</code><a class="headerlink" href="#ovito.data.SimulationCell.is2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies whether the system is two-dimensional (instead of three-dimensional). For two-dimensional systems, the PBC flag in the third direction (Z) and the third cell vector will typically be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Default</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SimulationCell.pbc">
<em class="property">property </em><code class="sig-name descname">pbc</code><a class="headerlink" href="#ovito.data.SimulationCell.pbc" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of three boolean values, which specify periodic boundary flags of the simulation cell along each cell vector.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SimulationCell.volume">
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#ovito.data.SimulationCell.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the volume of the three-dimensional simulation cell.
The volume is the absolute value of the determinant of the 3x3 submatrix formed by the three cell vectors.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SimulationCell.volume2D">
<em class="property">property </em><code class="sig-name descname">volume2D</code><a class="headerlink" href="#ovito.data.SimulationCell.volume2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the area of the two-dimensional simulation cell (see <a class="reference internal" href="#ovito.data.SimulationCell.is2D" title="ovito.data.SimulationCell.is2D"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is2D</span></code></a>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.SurfaceMesh">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">SurfaceMesh</code><a class="headerlink" href="#ovito.data.SurfaceMesh" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>A triangle mesh representation of a surface or, more precisely, a two-dimensional manifold that is closed and orientable. 
Typically, surface meshes are produced within OVITO by modifiers such as the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ConstructSurfaceModifier" title="ovito.modifiers.ConstructSurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructSurfaceModifier</span></code></a>, 
<a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CreateIsosurfaceModifier" title="ovito.modifiers.CreateIsosurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateIsosurfaceModifier</span></code></a> or <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CoordinationPolyhedraModifier" title="ovito.modifiers.CoordinationPolyhedraModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinationPolyhedraModifier</span></code></a>. 
Please see the <a class="reference external" href="./../../scene_objects.surface_mesh.html">user manual page on surface meshes</a> for a more in-depth description
of this geometric data struture.</p>
<p><strong>Periodic domains</strong></p>
<p>Surface meshes may be embedded in periodic domains, i.e. in simulation cells with periodic boundary conditions applied. 
That means triangles of a surface mesh can be connected to vertices on opposite sides of a simulation box and wrap around correctly. 
OVITO takes care of computing the intersections of the periodic surface with the box boundaries and automatically produces a non-periodic representation 
of the mesh when it comes to visualization, which is cut off at the box boundaries.</p>
<p>The spatial domain the surface mesh is embedded in is specified as a <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object attached to the 
<code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>. It is stored in the <a class="reference internal" href="#ovito.data.SurfaceMesh.domain" title="ovito.data.SurfaceMesh.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.domain</span></code></a> field. Note that this <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> 
may, in some situations, not be identidical to the global simulation <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> set for the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>.</p>
<p><strong>Spatial regions</strong></p>
<p>Being a closed, orientable manifold a surface mesh divides space into two or more spatial regions. 
For example, if the surface mesh was constructed by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ConstructSurfaceModifier" title="ovito.modifiers.ConstructSurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructSurfaceModifier</span></code></a> from a set of input particles, 
then the space enclosed by the surface is the “filled” region and the exterior space is the “empty” region containing no particles.</p>
<p>In general, the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> class manages a variable list of <a class="reference internal" href="#ovito.data.SurfaceMesh.regions" title="ovito.data.SurfaceMesh.regions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">regions</span></code></a>, each being identified by a numeric, zero-based index.
The <a class="reference internal" href="#ovito.data.SurfaceMesh.locate_point" title="ovito.data.SurfaceMesh.locate_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">locate_point()</span></code></a> method allows to determine which spatial region some point in space belongs to.</p>
<p>It may be that a surface mesh is degenerate. In such a case there is only one spatial region filling entire space. For example, 
when there are no input particles, the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ConstructSurfaceModifier" title="ovito.modifiers.ConstructSurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructSurfaceModifier</span></code></a> cannot construct a regular surface mesh and
the “empty” region fills the entire simulation cell. Conversely, if the periodic simulation cell is comletely filled with particles,
the “filled” region covers the entire simulation domain and the generated surface mesh will consist of no vertices or faces, i.e., it is degenerate.
To discriminate between the two situations, the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> class has a <a class="reference internal" href="#ovito.data.SurfaceMesh.space_filling_region" title="ovito.data.SurfaceMesh.space_filling_region"><code class="xref py py-attr docutils literal notranslate"><span class="pre">space_filling_region</span></code></a> field, which specifies
the spatial region that fills entire space in cases where the mesh is degenerate.</p>
<p><strong>File export</strong></p>
<p>A surface mesh can be exported to a geometry file in the form of a triangle mesh using OVITO’s <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_file()</span></code></a> function. 
To this end, a non-periodic version is produced by truncating triangles at the domain boundaries and generating “cap polygons” filling the holes that 
occur at the intersection of the surface with periodic domain boundaries. The following example code writes a VTK geometry file 
(<code class="docutils literal notranslate"><span class="pre">vtk/trimesh</span></code> export format):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span><span class="p">,</span> <span class="n">export_file</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="n">SurfaceMesh</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="k">import</span> <span class="n">ConstructSurfaceModifier</span>

<span class="c1"># Load a particle set and construct the surface mesh:</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ConstructSurfaceModifier</span><span class="p">(</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">2.8</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">surfaces</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">]</span>

<span class="c1"># Export the mesh to a VTK file for visualization with ParaView.</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;output/surface_mesh.vtk&#39;</span><span class="p">,</span> <span class="s1">&#39;vtk/trimesh&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Cutting planes</strong>”</p>
<p>A set of <em>cutting planes</em> can be assigned to a <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> to cut away parts of the mesh for visualization purposes.
This may be useful to e.g. cut a hole into a closed surface allowing to look inside the enclosed volume.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> objects manages a list of cutting planes, which are accessible through the <a class="reference internal" href="#ovito.data.SurfaceMesh.get_cutting_planes" title="ovito.data.SurfaceMesh.get_cutting_planes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cutting_planes()</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMesh.set_cutting_planes" title="ovito.data.SurfaceMesh.set_cutting_planes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_cutting_planes()</span></code></a>
methods. Note that the cuts are non-destructive and get performed only on the transient, non-periodic version of the mesh generated during image rendering or when exporting the mesh to a file.
The original data structures of the mesh are not affected.
The <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.SliceModifier" title="ovito.modifiers.SliceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">SliceModifier</span></code></a>, which can act on a <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>, performs the slice by simply adding a new entry to the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>’s
list of cutting planes.</p>
<p><strong>Mesh data access</strong></p>
<p>The methods <a class="reference internal" href="#ovito.data.SurfaceMesh.get_vertices" title="ovito.data.SurfaceMesh.get_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_vertices()</span></code></a>, <a class="reference internal" href="#ovito.data.SurfaceMesh.get_faces" title="ovito.data.SurfaceMesh.get_faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_faces()</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMesh.get_face_adjacency" title="ovito.data.SurfaceMesh.get_face_adjacency"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_face_adjacency()</span></code></a> methods provide access to the internal data of the
surface mesh.</p>
<dl class="py method">
<dt id="ovito.data.SurfaceMesh.domain">
<em class="property">property </em><code class="sig-name descname">domain</code><a class="headerlink" href="#ovito.data.SurfaceMesh.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> describing the (possibly periodic) domain which this surface mesh is embedded in. Note that this cell generally is indepenent of and may be different from the <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> found in the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.faces">
<em class="property">property </em><code class="sig-name descname">faces</code><a class="headerlink" href="#ovito.data.SurfaceMesh.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the properties of the faces of the mesh.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.get_cutting_planes">
<code class="sig-name descname">get_cutting_planes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.get_cutting_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>N</em> x 4 array containing the definitions of the <em>N</em> cutting planes attached to this <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>.</p>
<p>Each plane is defined by its unit normal vector and a signed displacement magnitude, which determines the plane’s distance from the coordinate origin along the normal, giving four numbers per plane in total. Those parts of the surface mesh which are on the positive side of the plane (in the direction the normal vector) are cut away.</p>
<p>Note that the returned Numpy array is a copy of the internal data stored by the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.get_face_adjacency">
<code class="sig-name descname">get_face_adjacency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.get_face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>M</em> x 3 array listing the indices of the three faces that are adjacent to each of the <em>M</em> triangle faces in the mesh. This information can be used to traverse the neighbors of triangle faces. Every triangle face has exactly three neighbors, because surface meshes are closed manifolds.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.get_faces">
<code class="sig-name descname">get_faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.get_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>M</em> x 3 array with the vertex indices of the <em>M</em> triangles in the mesh. Note that the returned Numpy array is a copy of the internal data stored by the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>. Also keep in mind that triangle faces can cross the domain boundaries if the periodic boundary conditions are used.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.get_vertices">
<code class="sig-name descname">get_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.get_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>N</em> x 3 array with the xyz coordinates of the <em>N</em> vertices in the mesh. Note that the returned Numpy array is a copy of the internal data stored by the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.locate_point">
<code class="sig-name descname">locate_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.locate_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the index of the spatial region that contains the given location in 3-D space. Note that region index -1 is typically reserved for the empty/exterior region, which doesn’t contain any atoms or particles. Regions starting at index 0 are used for filled or interior regions.</p>
<p>The parameter <em>eps</em> is used as a precision threshold to detect cases where the query point is positioned exactly on the surface itself, i.e. on the boundary between two spatial regions. Such a condition is indicated by the special return value <code class="docutils literal notranslate"><span class="pre">None</span></code>. You can set <em>eps</em> to 0.0 to disable the point-on-boundary test. Then the method will never yield <code class="docutils literal notranslate"><span class="pre">None</span></code> as a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – The (x,y,z) coordinates of the query point</p></li>
<li><p><strong>eps</strong> – Numerical precision threshold for point-on-boundary test</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The ID of the spatial region containing <em>pos</em>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if <em>pos</em> is exactly on the dividing surface between two regions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.regions">
<em class="property">property </em><code class="sig-name descname">regions</code><a class="headerlink" href="#ovito.data.SurfaceMesh.regions" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the properties of the spatial regions of the mesh.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.set_cutting_planes">
<code class="sig-name descname">set_cutting_planes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">planes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.set_cutting_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the cutting planes to be applied to this <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>. The array <em>planes</em> must follow the same format as the one returned by <a class="reference internal" href="#ovito.data.SurfaceMesh.get_cutting_planes" title="ovito.data.SurfaceMesh.get_cutting_planes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cutting_planes()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.space_filling_region">
<em class="property">property </em><code class="sig-name descname">space_filling_region</code><a class="headerlink" href="#ovito.data.SurfaceMesh.space_filling_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates the index of the spatial region that fills the entire domain in case the surface is degenerate, i.e. the mesh has zero faces. The invalid index -1 is typically associated with the empty (exterior) region.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.SurfaceMesh.vertices">
<em class="property">property </em><code class="sig-name descname">vertices</code><a class="headerlink" href="#ovito.data.SurfaceMesh.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the vertex properties of the mesh, including the vertex coordinates.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.TrajectoryLines">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">TrajectoryLines</code><a class="headerlink" href="#ovito.data.TrajectoryLines" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
</dd>
</dl>
<p>Data object that stores the trajectory lines of a set of particles, 
which have been traced by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.GenerateTrajectoryLinesModifier" title="ovito.modifiers.GenerateTrajectoryLinesModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateTrajectoryLinesModifier</span></code></a>. 
It is typically part of a pipeline’s output data collection, 
from where it can be accessed via the <a class="reference internal" href="#ovito.data.DataCollection.trajectories" title="ovito.data.DataCollection.trajectories"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.trajectories</span></code></a> field.</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryLines</span></code> object has an associated <a class="reference internal" href="ovito_vis.html#ovito.vis.TrajectoryVis" title="ovito.vis.TrajectoryVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryVis</span></code></a>
element, which controls the visual appearance of the trajectory lines in rendered images.
This visual element is accessible through the <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> attribute of the base class.</p>
<dl class="py method">
<dt id="ovito.data.TrajectoryLines.particle_ids">
<em class="property">property </em><code class="sig-name descname">particle_ids</code><a class="headerlink" href="#ovito.data.TrajectoryLines.particle_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array storing the particle IDs of the line vertices.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.TrajectoryLines.positions">
<em class="property">property </em><code class="sig-name descname">positions</code><a class="headerlink" href="#ovito.data.TrajectoryLines.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array storing the XYZ coordinates of the line vertices.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.TrajectoryLines.time_stamps">
<em class="property">property </em><code class="sig-name descname">time_stamps</code><a class="headerlink" href="#ovito.data.TrajectoryLines.time_stamps" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array storing the time stamps of the line vertices.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ovito.data.TriangleMesh">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">TriangleMesh</code><a class="headerlink" href="#ovito.data.TriangleMesh" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
</dd>
</dl>
<p>This data object type stores a triangle mesh describing general polyehdral geometry, which may be visualized side by side with the simulation data. 
Typically, triangle meshes are imported from an external geometry file using the <a class="reference internal" href="ovito_io.html#ovito.io.import_file" title="ovito.io.import_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_file()</span></code></a> function.
See also the corresponding <a class="reference external" href="./../../scene_objects.triangle_mesh.html">page of the user manual</a> for more information on triangle meshes. 
This class has no parameters or methods.</p>
<p>See also the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> class, which is another data object type in OVITO representing surface geometries.
In contrast to triangle meshes, however, surface meshes can live inside of periodic simulation domains and are true orientable, closed manifolds.
Furthermore, surface meshes can store arbitrary per-vertex and per-face property data – something triangle meshes cannot do.</p>
<p>The visual appearance of the triangle mesh in rendered images is controlled through the <a class="reference internal" href="ovito_vis.html#ovito.vis.TriangleMeshVis" title="ovito.vis.TriangleMeshVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMeshVis</span></code></a>
element attached to this data object (see base class <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a>).</p>
</dd></dl>

<dl class="py class">
<dt id="ovito.data.VoxelGrid">
<em class="property">class </em><code class="sig-prename descclassname">ovito.data.</code><code class="sig-name descname">VoxelGrid</code><a class="headerlink" href="#ovito.data.VoxelGrid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Base class</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
</dd>
</dl>
<p>A two- or three-dimensional structured grid. Each cell or voxel of the grid is of the same size and shape. The geometry of the entire grid, its <a class="reference internal" href="#ovito.data.VoxelGrid.domain" title="ovito.data.VoxelGrid.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a>, is defined by an attached <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object, which specific a three-dimensional parallelpiped or a two-dimensional parallelogram.</p>
<p>The <a class="reference internal" href="#ovito.data.VoxelGrid.shape" title="ovito.data.VoxelGrid.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a> property of the grid specifies the number of voxels along each domain cell vector. The size of an individual voxel is given by domain cell size divided by the number of voxels in each spatial direction.</p>
<p>Every voxel of the grid may be associated with one or more field values. The data for these <em>voxel properties</em> is stored in standard <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> objects, similar to particle or bond properties. Voxel properties can be accessed by name through the dictionary interface that the <code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code> class inherits from its <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class.</p>
<p>Voxel grids can be loaded from input data files, e.g. a CHGCAR file containing the electron density computed by the VASP code, or they can be dynamically generated within OVITO. The <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.SpatialBinningModifier" title="ovito.modifiers.SpatialBinningModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialBinningModifier</span></code></a> lets you project the information associated with the unstructured particle set to a structured voxel grid.</p>
<p>Given a voxel grid, the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CreateIsosurfaceModifier" title="ovito.modifiers.CreateIsosurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateIsosurfaceModifier</span></code></a> can then generate a <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> representing an isosurface for a field quantity defined on the voxel grid.</p>
<dl class="py method">
<dt id="ovito.data.VoxelGrid.domain">
<em class="property">property </em><code class="sig-name descname">domain</code><a class="headerlink" href="#ovito.data.VoxelGrid.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> describing the (possibly periodic) domain which this grid is embedded in. Note that this cell generally is indepenent of and may be different from the <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> found in the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="ovito.data.VoxelGrid.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#ovito.data.VoxelGrid.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple with the numbers of grid cells along each of the three cell vectors of the <a class="reference internal" href="#ovito.data.VoxelGrid.domain" title="ovito.data.VoxelGrid.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a>.</p>
<p>For two-dimensional grids, for which the <a class="reference internal" href="#ovito.data.SimulationCell.is2D" title="ovito.data.SimulationCell.is2D"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is2D</span></code></a> property of the <a class="reference internal" href="#ovito.data.VoxelGrid.domain" title="ovito.data.VoxelGrid.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a> is set to true, the third entry of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code> tuple is always equal to 1.</p>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction/running.html">OVITO’s Python interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/overview.html">High-level overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/file_io.html">File I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/pipelines.html">Data pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/data_model.html">Data model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/data_manipulation.html">Manipulating data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/custom_modifiers.html">User-defined modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/rendering.html">Rendering &amp; visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/advanced_topics.html">Advanced topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/examples.html">Code examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/version_changes.html">OVITO 2.9 Migration Guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ovito.html"><code class="docutils literal notranslate"><span class="pre">ovito</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ovito.data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_io.html"><code class="docutils literal notranslate"><span class="pre">ovito.io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_io_ase.html"><code class="docutils literal notranslate"><span class="pre">ovito.io.ase</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_modifiers.html"><code class="docutils literal notranslate"><span class="pre">ovito.modifiers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_pipeline.html"><code class="docutils literal notranslate"><span class="pre">ovito.pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_vis.html"><code class="docutils literal notranslate"><span class="pre">ovito.vis</span></code></a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ovito_io.html" title="ovito.io"
             >next</a> |</li>
        <li class="right" >
          <a href="ovito.html" title="ovito"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OVITO 3.4.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="docutils literal notranslate"><span class="pre">ovito.data</span></code></a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021 OVITO GmbH.
    </div>
  </body>
</html>